// Generated by the lua-protobuf compiler.
// You shouldn't be editing this file manually
//
// source proto file: packetSystem.proto
#pragma once

#include "lua-protobuf.h"
#include "packetSystem.pb.h"

#ifdef __cplusplus
extern "C" {
#endif

#include <lua/lua.h>

#ifdef __cplusplus
}

// register all messages in this package to a Lua state
static int lua_protobuf_pb_open(lua_State *L);

#include "connectionType.lua.h"
// Message EmptyPacket
// registers the message type with Lua
int lua_protobuf_pb_EmptyPacket_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_EmptyPacket_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_EmptyPacket_new(lua_State *L);

// return operation =
int lua_protobuf_pb_EmptyPacket_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_EmptyPacket_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_EmptyPacket_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_EmptyPacket_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_EmptyPacket_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_EmptyPacket_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_EmptyPacket_size(lua_State *L);
// end of message EmptyPacket

// Message Update
// registers the message type with Lua
int lua_protobuf_pb_Update_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_Update_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_Update_new(lua_State *L);

// return operation =
int lua_protobuf_pb_Update_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_Update_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_Update_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_Update_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_Update_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_Update_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_Update_size(lua_State *L);
// optional uint32 now = 1
int lua_protobuf_pb_Update_clear_now(lua_State *L);
int lua_protobuf_pb_Update_get_now(lua_State *L);
int lua_protobuf_pb_Update_set_now(lua_State *L);
int lua_protobuf_pb_Update_has_now(lua_State *L);

// optional uint32 delta = 2
int lua_protobuf_pb_Update_clear_delta(lua_State *L);
int lua_protobuf_pb_Update_get_delta(lua_State *L);
int lua_protobuf_pb_Update_set_delta(lua_State *L);
int lua_protobuf_pb_Update_has_delta(lua_State *L);

// end of message Update

// Message ListenConfig
// registers the message type with Lua
int lua_protobuf_pb_ListenConfig_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ListenConfig_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ListenConfig_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ListenConfig_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ListenConfig_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ListenConfig_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ListenConfig_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ListenConfig_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ListenConfig_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ListenConfig_size(lua_State *L);
// optional enum connectionType = 1
int lua_protobuf_pb_ListenConfig_clear_connectionType(lua_State *L);
int lua_protobuf_pb_ListenConfig_get_connectionType(lua_State *L);
int lua_protobuf_pb_ListenConfig_set_connectionType(lua_State *L);
int lua_protobuf_pb_ListenConfig_has_connectionType(lua_State *L);

// optional string listenIP = 2
int lua_protobuf_pb_ListenConfig_clear_listenIP(lua_State *L);
int lua_protobuf_pb_ListenConfig_get_listenIP(lua_State *L);
int lua_protobuf_pb_ListenConfig_set_listenIP(lua_State *L);
int lua_protobuf_pb_ListenConfig_has_listenIP(lua_State *L);

// optional int32 listenPort = 3
int lua_protobuf_pb_ListenConfig_clear_listenPort(lua_State *L);
int lua_protobuf_pb_ListenConfig_get_listenPort(lua_State *L);
int lua_protobuf_pb_ListenConfig_set_listenPort(lua_State *L);
int lua_protobuf_pb_ListenConfig_has_listenPort(lua_State *L);

// optional int32 maxConnection = 4
int lua_protobuf_pb_ListenConfig_clear_maxConnection(lua_State *L);
int lua_protobuf_pb_ListenConfig_get_maxConnection(lua_State *L);
int lua_protobuf_pb_ListenConfig_set_maxConnection(lua_State *L);
int lua_protobuf_pb_ListenConfig_has_maxConnection(lua_State *L);

// optional bool udp = 5
int lua_protobuf_pb_ListenConfig_clear_udp(lua_State *L);
int lua_protobuf_pb_ListenConfig_get_udp(lua_State *L);
int lua_protobuf_pb_ListenConfig_set_udp(lua_State *L);
int lua_protobuf_pb_ListenConfig_has_udp(lua_State *L);

// end of message ListenConfig

// Message InitServer
// registers the message type with Lua
int lua_protobuf_pb_InitServer_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_InitServer_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_InitServer_new(lua_State *L);

// return operation =
int lua_protobuf_pb_InitServer_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_InitServer_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_InitServer_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_InitServer_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_InitServer_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_InitServer_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_InitServer_size(lua_State *L);
// repeated message servers = 1
int lua_protobuf_pb_InitServer_clear_servers(lua_State *L);
int lua_protobuf_pb_InitServer_get_servers(lua_State *L);
int lua_protobuf_pb_InitServer_set_servers(lua_State *L);
int lua_protobuf_pb_InitServer_rawget_servers(lua_State *L);
int lua_protobuf_pb_InitServer_size_servers(lua_State *L);

// repeated message clients = 2
int lua_protobuf_pb_InitServer_clear_clients(lua_State *L);
int lua_protobuf_pb_InitServer_get_clients(lua_State *L);
int lua_protobuf_pb_InitServer_set_clients(lua_State *L);
int lua_protobuf_pb_InitServer_rawget_clients(lua_State *L);
int lua_protobuf_pb_InitServer_size_clients(lua_State *L);

// optional uint32 serverGuid = 3
int lua_protobuf_pb_InitServer_clear_serverGuid(lua_State *L);
int lua_protobuf_pb_InitServer_get_serverGuid(lua_State *L);
int lua_protobuf_pb_InitServer_set_serverGuid(lua_State *L);
int lua_protobuf_pb_InitServer_has_serverGuid(lua_State *L);

// optional string serverName = 4
int lua_protobuf_pb_InitServer_clear_serverName(lua_State *L);
int lua_protobuf_pb_InitServer_get_serverName(lua_State *L);
int lua_protobuf_pb_InitServer_set_serverName(lua_State *L);
int lua_protobuf_pb_InitServer_has_serverName(lua_State *L);

// optional enum connectionType = 5
int lua_protobuf_pb_InitServer_clear_connectionType(lua_State *L);
int lua_protobuf_pb_InitServer_get_connectionType(lua_State *L);
int lua_protobuf_pb_InitServer_set_connectionType(lua_State *L);
int lua_protobuf_pb_InitServer_has_connectionType(lua_State *L);

// end of message InitServer

// Message SetServerInfo
// registers the message type with Lua
int lua_protobuf_pb_SetServerInfo_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_SetServerInfo_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_SetServerInfo_new(lua_State *L);

// return operation =
int lua_protobuf_pb_SetServerInfo_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_SetServerInfo_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_SetServerInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_SetServerInfo_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_SetServerInfo_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_SetServerInfo_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_SetServerInfo_size(lua_State *L);
// optional uint32 serverGuid = 1
int lua_protobuf_pb_SetServerInfo_clear_serverGuid(lua_State *L);
int lua_protobuf_pb_SetServerInfo_get_serverGuid(lua_State *L);
int lua_protobuf_pb_SetServerInfo_set_serverGuid(lua_State *L);
int lua_protobuf_pb_SetServerInfo_has_serverGuid(lua_State *L);

// optional string serverName = 2
int lua_protobuf_pb_SetServerInfo_clear_serverName(lua_State *L);
int lua_protobuf_pb_SetServerInfo_get_serverName(lua_State *L);
int lua_protobuf_pb_SetServerInfo_set_serverName(lua_State *L);
int lua_protobuf_pb_SetServerInfo_has_serverName(lua_State *L);

// optional int32 level = 3
int lua_protobuf_pb_SetServerInfo_clear_level(lua_State *L);
int lua_protobuf_pb_SetServerInfo_get_level(lua_State *L);
int lua_protobuf_pb_SetServerInfo_set_level(lua_State *L);
int lua_protobuf_pb_SetServerInfo_has_level(lua_State *L);

// optional int32 maxPlayerCount = 4
int lua_protobuf_pb_SetServerInfo_clear_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_SetServerInfo_get_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_SetServerInfo_set_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_SetServerInfo_has_maxPlayerCount(lua_State *L);

// end of message SetServerInfo

// Message InitServerResponse
// registers the message type with Lua
int lua_protobuf_pb_InitServerResponse_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_InitServerResponse_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_InitServerResponse_new(lua_State *L);

// return operation =
int lua_protobuf_pb_InitServerResponse_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_InitServerResponse_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_InitServerResponse_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_InitServerResponse_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_InitServerResponse_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_InitServerResponse_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_InitServerResponse_size(lua_State *L);
// repeated message remoteServers = 1
int lua_protobuf_pb_InitServerResponse_clear_remoteServers(lua_State *L);
int lua_protobuf_pb_InitServerResponse_get_remoteServers(lua_State *L);
int lua_protobuf_pb_InitServerResponse_set_remoteServers(lua_State *L);
int lua_protobuf_pb_InitServerResponse_rawget_remoteServers(lua_State *L);
int lua_protobuf_pb_InitServerResponse_size_remoteServers(lua_State *L);

// end of message InitServerResponse

// Message ServerActive
// registers the message type with Lua
int lua_protobuf_pb_ServerActive_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ServerActive_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ServerActive_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ServerActive_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ServerActive_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ServerActive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ServerActive_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ServerActive_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ServerActive_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ServerActive_size(lua_State *L);
// optional message remoteServer = 1
int lua_protobuf_pb_ServerActive_clear_remoteServer(lua_State *L);
int lua_protobuf_pb_ServerActive_get_remoteServer(lua_State *L);
int lua_protobuf_pb_ServerActive_set_remoteServer(lua_State *L);
int lua_protobuf_pb_ServerActive_has_remoteServer(lua_State *L);

// end of message ServerActive

// Message InitGate
// registers the message type with Lua
int lua_protobuf_pb_InitGate_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_InitGate_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_InitGate_new(lua_State *L);

// return operation =
int lua_protobuf_pb_InitGate_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_InitGate_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_InitGate_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_InitGate_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_InitGate_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_InitGate_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_InitGate_size(lua_State *L);
// optional string gateAddress = 1
int lua_protobuf_pb_InitGate_clear_gateAddress(lua_State *L);
int lua_protobuf_pb_InitGate_get_gateAddress(lua_State *L);
int lua_protobuf_pb_InitGate_set_gateAddress(lua_State *L);
int lua_protobuf_pb_InitGate_has_gateAddress(lua_State *L);

// optional int32 gatePort = 2
int lua_protobuf_pb_InitGate_clear_gatePort(lua_State *L);
int lua_protobuf_pb_InitGate_get_gatePort(lua_State *L);
int lua_protobuf_pb_InitGate_set_gatePort(lua_State *L);
int lua_protobuf_pb_InitGate_has_gatePort(lua_State *L);

// optional uint32 gateGuid = 3
int lua_protobuf_pb_InitGate_clear_gateGuid(lua_State *L);
int lua_protobuf_pb_InitGate_get_gateGuid(lua_State *L);
int lua_protobuf_pb_InitGate_set_gateGuid(lua_State *L);
int lua_protobuf_pb_InitGate_has_gateGuid(lua_State *L);

// end of message InitGate

// Message ClientConnectGate
// registers the message type with Lua
int lua_protobuf_pb_ClientConnectGate_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ClientConnectGate_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ClientConnectGate_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ClientConnectGate_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ClientConnectGate_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ClientConnectGate_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ClientConnectGate_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ClientConnectGate_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ClientConnectGate_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ClientConnectGate_size(lua_State *L);
// optional string gateAddress = 1
int lua_protobuf_pb_ClientConnectGate_clear_gateAddress(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_get_gateAddress(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_set_gateAddress(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_has_gateAddress(lua_State *L);

// optional int32 gatePort = 2
int lua_protobuf_pb_ClientConnectGate_clear_gatePort(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_get_gatePort(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_set_gatePort(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_has_gatePort(lua_State *L);

// optional uint32 newGuid = 3
int lua_protobuf_pb_ClientConnectGate_clear_newGuid(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_get_newGuid(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_set_newGuid(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_has_newGuid(lua_State *L);

// optional uint32 waitNum = 4
int lua_protobuf_pb_ClientConnectGate_clear_waitNum(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_get_waitNum(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_set_waitNum(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_has_waitNum(lua_State *L);

// optional bytes securityKey = 5
int lua_protobuf_pb_ClientConnectGate_clear_securityKey(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_get_securityKey(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_set_securityKey(lua_State *L);
int lua_protobuf_pb_ClientConnectGate_has_securityKey(lua_State *L);

// end of message ClientConnectGate

// Message ChangeServerGuid
// registers the message type with Lua
int lua_protobuf_pb_ChangeServerGuid_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ChangeServerGuid_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ChangeServerGuid_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ChangeServerGuid_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ChangeServerGuid_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ChangeServerGuid_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ChangeServerGuid_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ChangeServerGuid_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ChangeServerGuid_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ChangeServerGuid_size(lua_State *L);
// optional uint32 newGuid = 1
int lua_protobuf_pb_ChangeServerGuid_clear_newGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_get_newGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_set_newGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_has_newGuid(lua_State *L);

// optional uint32 serverGuid = 2
int lua_protobuf_pb_ChangeServerGuid_clear_serverGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_get_serverGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_set_serverGuid(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_has_serverGuid(lua_State *L);

// optional uint32 groupID = 3
int lua_protobuf_pb_ChangeServerGuid_clear_groupID(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_get_groupID(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_set_groupID(lua_State *L);
int lua_protobuf_pb_ChangeServerGuid_has_groupID(lua_State *L);

// end of message ChangeServerGuid

// Message GatePlayerCount
// registers the message type with Lua
int lua_protobuf_pb_GatePlayerCount_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_GatePlayerCount_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_GatePlayerCount_new(lua_State *L);

// return operation =
int lua_protobuf_pb_GatePlayerCount_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_GatePlayerCount_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_GatePlayerCount_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_GatePlayerCount_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_GatePlayerCount_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_GatePlayerCount_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_GatePlayerCount_size(lua_State *L);
// optional uint32 gateGuid = 1
int lua_protobuf_pb_GatePlayerCount_clear_gateGuid(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_get_gateGuid(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_set_gateGuid(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_has_gateGuid(lua_State *L);

// optional int32 playerCount = 2
int lua_protobuf_pb_GatePlayerCount_clear_playerCount(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_get_playerCount(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_set_playerCount(lua_State *L);
int lua_protobuf_pb_GatePlayerCount_has_playerCount(lua_State *L);

// end of message GatePlayerCount

// Message NewIncomingConnection
// registers the message type with Lua
int lua_protobuf_pb_NewIncomingConnection_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_NewIncomingConnection_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_NewIncomingConnection_new(lua_State *L);

// return operation =
int lua_protobuf_pb_NewIncomingConnection_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_NewIncomingConnection_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_NewIncomingConnection_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_NewIncomingConnection_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_NewIncomingConnection_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_NewIncomingConnection_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_NewIncomingConnection_size(lua_State *L);
// optional enum connectionType = 1
int lua_protobuf_pb_NewIncomingConnection_clear_connectionType(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_get_connectionType(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_set_connectionType(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_has_connectionType(lua_State *L);

// optional uint32 remoteGuid = 2
int lua_protobuf_pb_NewIncomingConnection_clear_remoteGuid(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_get_remoteGuid(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_set_remoteGuid(lua_State *L);
int lua_protobuf_pb_NewIncomingConnection_has_remoteGuid(lua_State *L);

// end of message NewIncomingConnection

// Message ConnectionRequestAccepted
// registers the message type with Lua
int lua_protobuf_pb_ConnectionRequestAccepted_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ConnectionRequestAccepted_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ConnectionRequestAccepted_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ConnectionRequestAccepted_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ConnectionRequestAccepted_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ConnectionRequestAccepted_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ConnectionRequestAccepted_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ConnectionRequestAccepted_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ConnectionRequestAccepted_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ConnectionRequestAccepted_size(lua_State *L);
// optional enum connectionType = 1
int lua_protobuf_pb_ConnectionRequestAccepted_clear_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_get_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_set_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_has_connectionType(lua_State *L);

// optional uint32 remoteGuid = 2
int lua_protobuf_pb_ConnectionRequestAccepted_clear_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_get_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_set_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionRequestAccepted_has_remoteGuid(lua_State *L);

// end of message ConnectionRequestAccepted

// Message ConnectionAttemptFailed
// registers the message type with Lua
int lua_protobuf_pb_ConnectionAttemptFailed_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ConnectionAttemptFailed_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ConnectionAttemptFailed_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ConnectionAttemptFailed_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ConnectionAttemptFailed_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ConnectionAttemptFailed_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ConnectionAttemptFailed_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ConnectionAttemptFailed_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ConnectionAttemptFailed_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ConnectionAttemptFailed_size(lua_State *L);
// optional uint32 remoteGuid = 1
int lua_protobuf_pb_ConnectionAttemptFailed_clear_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_get_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_set_remoteGuid(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_has_remoteGuid(lua_State *L);

// optional string IP = 2
int lua_protobuf_pb_ConnectionAttemptFailed_clear_IP(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_get_IP(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_set_IP(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_has_IP(lua_State *L);

// optional int32 port = 3
int lua_protobuf_pb_ConnectionAttemptFailed_clear_port(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_get_port(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_set_port(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_has_port(lua_State *L);

// optional enum connectionType = 4
int lua_protobuf_pb_ConnectionAttemptFailed_clear_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_get_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_set_connectionType(lua_State *L);
int lua_protobuf_pb_ConnectionAttemptFailed_has_connectionType(lua_State *L);

// end of message ConnectionAttemptFailed

// Message DisconnectionNotification
// registers the message type with Lua
int lua_protobuf_pb_DisconnectionNotification_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_DisconnectionNotification_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_DisconnectionNotification_new(lua_State *L);

// return operation =
int lua_protobuf_pb_DisconnectionNotification_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_DisconnectionNotification_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_DisconnectionNotification_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_DisconnectionNotification_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_DisconnectionNotification_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_DisconnectionNotification_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_DisconnectionNotification_size(lua_State *L);
// optional enum connectionType = 1
int lua_protobuf_pb_DisconnectionNotification_clear_connectionType(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_get_connectionType(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_set_connectionType(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_has_connectionType(lua_State *L);

// optional uint32 remoteGuid = 2
int lua_protobuf_pb_DisconnectionNotification_clear_remoteGuid(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_get_remoteGuid(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_set_remoteGuid(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_has_remoteGuid(lua_State *L);

// optional bool bPassive = 3
int lua_protobuf_pb_DisconnectionNotification_clear_bPassive(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_get_bPassive(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_set_bPassive(lua_State *L);
int lua_protobuf_pb_DisconnectionNotification_has_bPassive(lua_State *L);

// end of message DisconnectionNotification

// Message LoginError
// registers the message type with Lua
int lua_protobuf_pb_LoginError_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_LoginError_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_LoginError_new(lua_State *L);

// return operation =
int lua_protobuf_pb_LoginError_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_LoginError_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_LoginError_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_LoginError_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_LoginError_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_LoginError_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_LoginError_size(lua_State *L);
// optional uint32 playerGuid = 1
int lua_protobuf_pb_LoginError_clear_playerGuid(lua_State *L);
int lua_protobuf_pb_LoginError_get_playerGuid(lua_State *L);
int lua_protobuf_pb_LoginError_set_playerGuid(lua_State *L);
int lua_protobuf_pb_LoginError_has_playerGuid(lua_State *L);

// end of message LoginError

// Message FlushConfig
// registers the message type with Lua
int lua_protobuf_pb_FlushConfig_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_FlushConfig_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_FlushConfig_new(lua_State *L);

// return operation =
int lua_protobuf_pb_FlushConfig_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_FlushConfig_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_FlushConfig_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_FlushConfig_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_FlushConfig_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_FlushConfig_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_FlushConfig_size(lua_State *L);
// optional string flushModule = 1
int lua_protobuf_pb_FlushConfig_clear_flushModule(lua_State *L);
int lua_protobuf_pb_FlushConfig_get_flushModule(lua_State *L);
int lua_protobuf_pb_FlushConfig_set_flushModule(lua_State *L);
int lua_protobuf_pb_FlushConfig_has_flushModule(lua_State *L);

// end of message FlushConfig

// Message ShutServerDown
// registers the message type with Lua
int lua_protobuf_pb_ShutServerDown_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ShutServerDown_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ShutServerDown_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ShutServerDown_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ShutServerDown_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ShutServerDown_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ShutServerDown_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ShutServerDown_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ShutServerDown_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ShutServerDown_size(lua_State *L);
// optional int32 afterTime = 1
int lua_protobuf_pb_ShutServerDown_clear_afterTime(lua_State *L);
int lua_protobuf_pb_ShutServerDown_get_afterTime(lua_State *L);
int lua_protobuf_pb_ShutServerDown_set_afterTime(lua_State *L);
int lua_protobuf_pb_ShutServerDown_has_afterTime(lua_State *L);

// end of message ShutServerDown

// Message ClockDifferential
// registers the message type with Lua
int lua_protobuf_pb_ClockDifferential_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ClockDifferential_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ClockDifferential_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ClockDifferential_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ClockDifferential_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ClockDifferential_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ClockDifferential_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ClockDifferential_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ClockDifferential_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ClockDifferential_size(lua_State *L);
// optional uint32 beginTime = 1
int lua_protobuf_pb_ClockDifferential_clear_beginTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_get_beginTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_set_beginTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_has_beginTime(lua_State *L);

// optional uint32 syncTime = 2
int lua_protobuf_pb_ClockDifferential_clear_syncTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_get_syncTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_set_syncTime(lua_State *L);
int lua_protobuf_pb_ClockDifferential_has_syncTime(lua_State *L);

// optional uint32 guid = 3
int lua_protobuf_pb_ClockDifferential_clear_guid(lua_State *L);
int lua_protobuf_pb_ClockDifferential_get_guid(lua_State *L);
int lua_protobuf_pb_ClockDifferential_set_guid(lua_State *L);
int lua_protobuf_pb_ClockDifferential_has_guid(lua_State *L);

// end of message ClockDifferential

// Message Bulletin
// registers the message type with Lua
int lua_protobuf_pb_Bulletin_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_Bulletin_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_Bulletin_new(lua_State *L);

// return operation =
int lua_protobuf_pb_Bulletin_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_Bulletin_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_Bulletin_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_Bulletin_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_Bulletin_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_Bulletin_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_Bulletin_size(lua_State *L);
// optional string content = 1
int lua_protobuf_pb_Bulletin_clear_content(lua_State *L);
int lua_protobuf_pb_Bulletin_get_content(lua_State *L);
int lua_protobuf_pb_Bulletin_set_content(lua_State *L);
int lua_protobuf_pb_Bulletin_has_content(lua_State *L);

// end of message Bulletin

// Message VersionCheck
// registers the message type with Lua
int lua_protobuf_pb_VersionCheck_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_VersionCheck_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_VersionCheck_new(lua_State *L);

// return operation =
int lua_protobuf_pb_VersionCheck_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_VersionCheck_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_VersionCheck_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_VersionCheck_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_VersionCheck_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_VersionCheck_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_VersionCheck_size(lua_State *L);
// optional string version = 1
int lua_protobuf_pb_VersionCheck_clear_version(lua_State *L);
int lua_protobuf_pb_VersionCheck_get_version(lua_State *L);
int lua_protobuf_pb_VersionCheck_set_version(lua_State *L);
int lua_protobuf_pb_VersionCheck_has_version(lua_State *L);

// optional uint32 guid = 2
int lua_protobuf_pb_VersionCheck_clear_guid(lua_State *L);
int lua_protobuf_pb_VersionCheck_get_guid(lua_State *L);
int lua_protobuf_pb_VersionCheck_set_guid(lua_State *L);
int lua_protobuf_pb_VersionCheck_has_guid(lua_State *L);

// end of message VersionCheck

// Message VersionCheckFaild
// registers the message type with Lua
int lua_protobuf_pb_VersionCheckFaild_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_VersionCheckFaild_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_VersionCheckFaild_new(lua_State *L);

// return operation =
int lua_protobuf_pb_VersionCheckFaild_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_VersionCheckFaild_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_VersionCheckFaild_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_VersionCheckFaild_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_VersionCheckFaild_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_VersionCheckFaild_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_VersionCheckFaild_size(lua_State *L);
// end of message VersionCheckFaild

// Message ProxyMessage
// registers the message type with Lua
int lua_protobuf_pb_ProxyMessage_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ProxyMessage_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ProxyMessage_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ProxyMessage_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ProxyMessage_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ProxyMessage_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ProxyMessage_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ProxyMessage_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ProxyMessage_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ProxyMessage_size(lua_State *L);
// optional uint32 playerGuid = 1
int lua_protobuf_pb_ProxyMessage_clear_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyMessage_get_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyMessage_set_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyMessage_has_playerGuid(lua_State *L);

// optional bool status = 2
int lua_protobuf_pb_ProxyMessage_clear_status(lua_State *L);
int lua_protobuf_pb_ProxyMessage_get_status(lua_State *L);
int lua_protobuf_pb_ProxyMessage_set_status(lua_State *L);
int lua_protobuf_pb_ProxyMessage_has_status(lua_State *L);

// end of message ProxyMessage

// Message ReInitProxy
// registers the message type with Lua
int lua_protobuf_pb_ReInitProxy_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ReInitProxy_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ReInitProxy_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ReInitProxy_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ReInitProxy_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ReInitProxy_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ReInitProxy_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ReInitProxy_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ReInitProxy_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ReInitProxy_size(lua_State *L);
// end of message ReInitProxy

// Message PakCheckCodeQuery
// registers the message type with Lua
int lua_protobuf_pb_PakCheckCodeQuery_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_PakCheckCodeQuery_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_PakCheckCodeQuery_new(lua_State *L);

// return operation =
int lua_protobuf_pb_PakCheckCodeQuery_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_PakCheckCodeQuery_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_PakCheckCodeQuery_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_PakCheckCodeQuery_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_PakCheckCodeQuery_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_PakCheckCodeQuery_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_PakCheckCodeQuery_size(lua_State *L);
// optional string version = 1
int lua_protobuf_pb_PakCheckCodeQuery_clear_version(lua_State *L);
int lua_protobuf_pb_PakCheckCodeQuery_get_version(lua_State *L);
int lua_protobuf_pb_PakCheckCodeQuery_set_version(lua_State *L);
int lua_protobuf_pb_PakCheckCodeQuery_has_version(lua_State *L);

// end of message PakCheckCodeQuery

// Message PakCheckCode
// registers the message type with Lua
int lua_protobuf_pb_PakCheckCode_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_PakCheckCode_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_PakCheckCode_new(lua_State *L);

// return operation =
int lua_protobuf_pb_PakCheckCode_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_PakCheckCode_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_PakCheckCode_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_PakCheckCode_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_PakCheckCode_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_PakCheckCode_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_PakCheckCode_size(lua_State *L);
// optional string pakName = 1
int lua_protobuf_pb_PakCheckCode_clear_pakName(lua_State *L);
int lua_protobuf_pb_PakCheckCode_get_pakName(lua_State *L);
int lua_protobuf_pb_PakCheckCode_set_pakName(lua_State *L);
int lua_protobuf_pb_PakCheckCode_has_pakName(lua_State *L);

// optional string checkCode = 2
int lua_protobuf_pb_PakCheckCode_clear_checkCode(lua_State *L);
int lua_protobuf_pb_PakCheckCode_get_checkCode(lua_State *L);
int lua_protobuf_pb_PakCheckCode_set_checkCode(lua_State *L);
int lua_protobuf_pb_PakCheckCode_has_checkCode(lua_State *L);

// end of message PakCheckCode

// Message PakCheckCodeRes
// registers the message type with Lua
int lua_protobuf_pb_PakCheckCodeRes_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_PakCheckCodeRes_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_PakCheckCodeRes_new(lua_State *L);

// return operation =
int lua_protobuf_pb_PakCheckCodeRes_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_PakCheckCodeRes_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_PakCheckCodeRes_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_PakCheckCodeRes_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_PakCheckCodeRes_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_PakCheckCodeRes_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_PakCheckCodeRes_size(lua_State *L);
// repeated message pakCheckCodes = 1
int lua_protobuf_pb_PakCheckCodeRes_clear_pakCheckCodes(lua_State *L);
int lua_protobuf_pb_PakCheckCodeRes_get_pakCheckCodes(lua_State *L);
int lua_protobuf_pb_PakCheckCodeRes_set_pakCheckCodes(lua_State *L);
int lua_protobuf_pb_PakCheckCodeRes_rawget_pakCheckCodes(lua_State *L);
int lua_protobuf_pb_PakCheckCodeRes_size_pakCheckCodes(lua_State *L);

// end of message PakCheckCodeRes

// Message PakCheckFailed
// registers the message type with Lua
int lua_protobuf_pb_PakCheckFailed_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_PakCheckFailed_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_PakCheckFailed_new(lua_State *L);

// return operation =
int lua_protobuf_pb_PakCheckFailed_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_PakCheckFailed_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_PakCheckFailed_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_PakCheckFailed_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_PakCheckFailed_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_PakCheckFailed_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_PakCheckFailed_size(lua_State *L);
// repeated string pakNames = 1
int lua_protobuf_pb_PakCheckFailed_clear_pakNames(lua_State *L);
int lua_protobuf_pb_PakCheckFailed_get_pakNames(lua_State *L);
int lua_protobuf_pb_PakCheckFailed_set_pakNames(lua_State *L);
int lua_protobuf_pb_PakCheckFailed_size_pakNames(lua_State *L);

// end of message PakCheckFailed

// Message InitPveGameServer
// registers the message type with Lua
int lua_protobuf_pb_InitPveGameServer_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_InitPveGameServer_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_InitPveGameServer_new(lua_State *L);

// return operation =
int lua_protobuf_pb_InitPveGameServer_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_InitPveGameServer_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_InitPveGameServer_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_InitPveGameServer_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_InitPveGameServer_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_InitPveGameServer_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_InitPveGameServer_size(lua_State *L);
// optional int32 maxPlayerCount = 1
int lua_protobuf_pb_InitPveGameServer_clear_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_InitPveGameServer_get_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_InitPveGameServer_set_maxPlayerCount(lua_State *L);
int lua_protobuf_pb_InitPveGameServer_has_maxPlayerCount(lua_State *L);

// end of message InitPveGameServer

// Message IncPlayer
// registers the message type with Lua
int lua_protobuf_pb_IncPlayer_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_IncPlayer_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_IncPlayer_new(lua_State *L);

// return operation =
int lua_protobuf_pb_IncPlayer_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_IncPlayer_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_IncPlayer_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_IncPlayer_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_IncPlayer_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_IncPlayer_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_IncPlayer_size(lua_State *L);
// optional uint32 playerGuid = 1
int lua_protobuf_pb_IncPlayer_clear_playerGuid(lua_State *L);
int lua_protobuf_pb_IncPlayer_get_playerGuid(lua_State *L);
int lua_protobuf_pb_IncPlayer_set_playerGuid(lua_State *L);
int lua_protobuf_pb_IncPlayer_has_playerGuid(lua_State *L);

// end of message IncPlayer

// Message DeIncPlayer
// registers the message type with Lua
int lua_protobuf_pb_DeIncPlayer_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_DeIncPlayer_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_DeIncPlayer_new(lua_State *L);

// return operation =
int lua_protobuf_pb_DeIncPlayer_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_DeIncPlayer_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_DeIncPlayer_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_DeIncPlayer_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_DeIncPlayer_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_DeIncPlayer_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_DeIncPlayer_size(lua_State *L);
// end of message DeIncPlayer

// Message ClientLog
// registers the message type with Lua
int lua_protobuf_pb_ClientLog_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ClientLog_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ClientLog_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ClientLog_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ClientLog_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ClientLog_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ClientLog_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ClientLog_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ClientLog_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ClientLog_size(lua_State *L);
// required bool error = 1
int lua_protobuf_pb_ClientLog_clear_error(lua_State *L);
int lua_protobuf_pb_ClientLog_get_error(lua_State *L);
int lua_protobuf_pb_ClientLog_set_error(lua_State *L);
int lua_protobuf_pb_ClientLog_has_error(lua_State *L);

// required string machineID = 2
int lua_protobuf_pb_ClientLog_clear_machineID(lua_State *L);
int lua_protobuf_pb_ClientLog_get_machineID(lua_State *L);
int lua_protobuf_pb_ClientLog_set_machineID(lua_State *L);
int lua_protobuf_pb_ClientLog_has_machineID(lua_State *L);

// required string content = 3
int lua_protobuf_pb_ClientLog_clear_content(lua_State *L);
int lua_protobuf_pb_ClientLog_get_content(lua_State *L);
int lua_protobuf_pb_ClientLog_set_content(lua_State *L);
int lua_protobuf_pb_ClientLog_has_content(lua_State *L);

// required string memoryStatus = 4
int lua_protobuf_pb_ClientLog_clear_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientLog_get_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientLog_set_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientLog_has_memoryStatus(lua_State *L);

// end of message ClientLog

// Message ClientDump
// registers the message type with Lua
int lua_protobuf_pb_ClientDump_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ClientDump_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ClientDump_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ClientDump_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ClientDump_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ClientDump_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ClientDump_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ClientDump_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ClientDump_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ClientDump_size(lua_State *L);
// required string machineID = 1
int lua_protobuf_pb_ClientDump_clear_machineID(lua_State *L);
int lua_protobuf_pb_ClientDump_get_machineID(lua_State *L);
int lua_protobuf_pb_ClientDump_set_machineID(lua_State *L);
int lua_protobuf_pb_ClientDump_has_machineID(lua_State *L);

// required string dumpName = 2
int lua_protobuf_pb_ClientDump_clear_dumpName(lua_State *L);
int lua_protobuf_pb_ClientDump_get_dumpName(lua_State *L);
int lua_protobuf_pb_ClientDump_set_dumpName(lua_State *L);
int lua_protobuf_pb_ClientDump_has_dumpName(lua_State *L);

// required bytes dumpContent = 3
int lua_protobuf_pb_ClientDump_clear_dumpContent(lua_State *L);
int lua_protobuf_pb_ClientDump_get_dumpContent(lua_State *L);
int lua_protobuf_pb_ClientDump_set_dumpContent(lua_State *L);
int lua_protobuf_pb_ClientDump_has_dumpContent(lua_State *L);

// required string memoryStatus = 4
int lua_protobuf_pb_ClientDump_clear_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientDump_get_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientDump_set_memoryStatus(lua_State *L);
int lua_protobuf_pb_ClientDump_has_memoryStatus(lua_State *L);

// end of message ClientDump

// Message SystemKeepalive
// registers the message type with Lua
int lua_protobuf_pb_SystemKeepalive_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_SystemKeepalive_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_SystemKeepalive_new(lua_State *L);

// return operation =
int lua_protobuf_pb_SystemKeepalive_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_SystemKeepalive_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_SystemKeepalive_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_SystemKeepalive_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_SystemKeepalive_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_SystemKeepalive_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_SystemKeepalive_size(lua_State *L);
// end of message SystemKeepalive

// Message ProxyBalanceAdd
// registers the message type with Lua
int lua_protobuf_pb_ProxyBalanceAdd_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ProxyBalanceAdd_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ProxyBalanceAdd_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ProxyBalanceAdd_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ProxyBalanceAdd_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ProxyBalanceAdd_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ProxyBalanceAdd_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ProxyBalanceAdd_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ProxyBalanceAdd_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ProxyBalanceAdd_size(lua_State *L);
// optional uint32 playerGuid = 1
int lua_protobuf_pb_ProxyBalanceAdd_clear_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceAdd_get_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceAdd_set_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceAdd_has_playerGuid(lua_State *L);

// end of message ProxyBalanceAdd

// Message ProxyBalanceDel
// registers the message type with Lua
int lua_protobuf_pb_ProxyBalanceDel_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_ProxyBalanceDel_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_ProxyBalanceDel_new(lua_State *L);

// return operation =
int lua_protobuf_pb_ProxyBalanceDel_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_ProxyBalanceDel_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_ProxyBalanceDel_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_ProxyBalanceDel_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_ProxyBalanceDel_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_ProxyBalanceDel_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_ProxyBalanceDel_size(lua_State *L);
// optional uint32 playerGuid = 1
int lua_protobuf_pb_ProxyBalanceDel_clear_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceDel_get_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceDel_set_playerGuid(lua_State *L);
int lua_protobuf_pb_ProxyBalanceDel_has_playerGuid(lua_State *L);

// end of message ProxyBalanceDel

// Message InitUdpProxy
// registers the message type with Lua
int lua_protobuf_pb_InitUdpProxy_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_InitUdpProxy_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_InitUdpProxy_new(lua_State *L);

// return operation =
int lua_protobuf_pb_InitUdpProxy_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_InitUdpProxy_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_InitUdpProxy_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_InitUdpProxy_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_InitUdpProxy_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_InitUdpProxy_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_InitUdpProxy_size(lua_State *L);
// optional string udpProxyHost = 1
int lua_protobuf_pb_InitUdpProxy_clear_udpProxyHost(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_get_udpProxyHost(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_set_udpProxyHost(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_has_udpProxyHost(lua_State *L);

// optional int32 udpProxyPort = 2
int lua_protobuf_pb_InitUdpProxy_clear_udpProxyPort(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_get_udpProxyPort(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_set_udpProxyPort(lua_State *L);
int lua_protobuf_pb_InitUdpProxy_has_udpProxyPort(lua_State *L);

// end of message InitUdpProxy

// Message PlayerGuidNotify
// registers the message type with Lua
int lua_protobuf_pb_PlayerGuidNotify_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_PlayerGuidNotify_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_PlayerGuidNotify_new(lua_State *L);

// return operation =
int lua_protobuf_pb_PlayerGuidNotify_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_PlayerGuidNotify_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_PlayerGuidNotify_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_PlayerGuidNotify_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_PlayerGuidNotify_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_PlayerGuidNotify_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_PlayerGuidNotify_size(lua_State *L);
// optional uint32 clientGuid = 1
int lua_protobuf_pb_PlayerGuidNotify_clear_clientGuid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_get_clientGuid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_set_clientGuid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_has_clientGuid(lua_State *L);

// optional bytes uid = 2
int lua_protobuf_pb_PlayerGuidNotify_clear_uid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_get_uid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_set_uid(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_has_uid(lua_State *L);

// optional bytes token = 3
int lua_protobuf_pb_PlayerGuidNotify_clear_token(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_get_token(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_set_token(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_has_token(lua_State *L);

// optional int32 robot = 4
int lua_protobuf_pb_PlayerGuidNotify_clear_robot(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_get_robot(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_set_robot(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_has_robot(lua_State *L);

// optional bytes securityKey = 5
int lua_protobuf_pb_PlayerGuidNotify_clear_securityKey(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_get_securityKey(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_set_securityKey(lua_State *L);
int lua_protobuf_pb_PlayerGuidNotify_has_securityKey(lua_State *L);

// end of message PlayerGuidNotify

// Message SetPacketStat
// registers the message type with Lua
int lua_protobuf_pb_SetPacketStat_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_SetPacketStat_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_SetPacketStat_new(lua_State *L);

// return operation =
int lua_protobuf_pb_SetPacketStat_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_SetPacketStat_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_SetPacketStat_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_SetPacketStat_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_SetPacketStat_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_SetPacketStat_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_SetPacketStat_size(lua_State *L);
// optional bool needStat = 1
int lua_protobuf_pb_SetPacketStat_clear_needStat(lua_State *L);
int lua_protobuf_pb_SetPacketStat_get_needStat(lua_State *L);
int lua_protobuf_pb_SetPacketStat_set_needStat(lua_State *L);
int lua_protobuf_pb_SetPacketStat_has_needStat(lua_State *L);

// optional bool needStatTime = 2
int lua_protobuf_pb_SetPacketStat_clear_needStatTime(lua_State *L);
int lua_protobuf_pb_SetPacketStat_get_needStatTime(lua_State *L);
int lua_protobuf_pb_SetPacketStat_set_needStatTime(lua_State *L);
int lua_protobuf_pb_SetPacketStat_has_needStatTime(lua_State *L);

// end of message SetPacketStat

// Message UploadFileReq
// registers the message type with Lua
int lua_protobuf_pb_UploadFileReq_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_UploadFileReq_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_UploadFileReq_new(lua_State *L);

// return operation =
int lua_protobuf_pb_UploadFileReq_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_UploadFileReq_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_UploadFileReq_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_UploadFileReq_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_UploadFileReq_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_UploadFileReq_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_UploadFileReq_size(lua_State *L);
// optional string fileName = 1
int lua_protobuf_pb_UploadFileReq_clear_fileName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_get_fileName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_set_fileName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_has_fileName(lua_State *L);

// optional string roleName = 2
int lua_protobuf_pb_UploadFileReq_clear_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_get_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_set_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReq_has_roleName(lua_State *L);

// end of message UploadFileReq

// Message UploadFileReply
// registers the message type with Lua
int lua_protobuf_pb_UploadFileReply_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_UploadFileReply_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_UploadFileReply_new(lua_State *L);

// return operation =
int lua_protobuf_pb_UploadFileReply_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_UploadFileReply_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_UploadFileReply_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_UploadFileReply_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_UploadFileReply_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_UploadFileReply_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_UploadFileReply_size(lua_State *L);
// optional string roleName = 1
int lua_protobuf_pb_UploadFileReply_clear_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReply_get_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReply_set_roleName(lua_State *L);
int lua_protobuf_pb_UploadFileReply_has_roleName(lua_State *L);

// optional bytes data = 2
int lua_protobuf_pb_UploadFileReply_clear_data(lua_State *L);
int lua_protobuf_pb_UploadFileReply_get_data(lua_State *L);
int lua_protobuf_pb_UploadFileReply_set_data(lua_State *L);
int lua_protobuf_pb_UploadFileReply_has_data(lua_State *L);

// end of message UploadFileReply

// Message CollectModuleInfo
// registers the message type with Lua
int lua_protobuf_pb_CollectModuleInfo_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_CollectModuleInfo_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_CollectModuleInfo_new(lua_State *L);

// return operation =
int lua_protobuf_pb_CollectModuleInfo_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_CollectModuleInfo_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_CollectModuleInfo_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_CollectModuleInfo_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_CollectModuleInfo_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_CollectModuleInfo_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_CollectModuleInfo_size(lua_State *L);
// optional uint32 playerID = 1
int lua_protobuf_pb_CollectModuleInfo_clear_playerID(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_get_playerID(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_set_playerID(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_has_playerID(lua_State *L);

// optional bytes sign = 2
int lua_protobuf_pb_CollectModuleInfo_clear_sign(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_get_sign(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_set_sign(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_has_sign(lua_State *L);

// optional bytes modulePath = 3
int lua_protobuf_pb_CollectModuleInfo_clear_modulePath(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_get_modulePath(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_set_modulePath(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_has_modulePath(lua_State *L);

// optional uint32 time = 4
int lua_protobuf_pb_CollectModuleInfo_clear_time(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_get_time(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_set_time(lua_State *L);
int lua_protobuf_pb_CollectModuleInfo_has_time(lua_State *L);

// end of message CollectModuleInfo

// Message SyncItemLock
// registers the message type with Lua
int lua_protobuf_pb_SyncItemLock_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_SyncItemLock_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_SyncItemLock_new(lua_State *L);

// return operation =
int lua_protobuf_pb_SyncItemLock_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_SyncItemLock_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_SyncItemLock_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_SyncItemLock_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_SyncItemLock_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_SyncItemLock_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_SyncItemLock_size(lua_State *L);
// optional string account = 1
int lua_protobuf_pb_SyncItemLock_clear_account(lua_State *L);
int lua_protobuf_pb_SyncItemLock_get_account(lua_State *L);
int lua_protobuf_pb_SyncItemLock_set_account(lua_State *L);
int lua_protobuf_pb_SyncItemLock_has_account(lua_State *L);

// optional uint32 playerID = 2
int lua_protobuf_pb_SyncItemLock_clear_playerID(lua_State *L);
int lua_protobuf_pb_SyncItemLock_get_playerID(lua_State *L);
int lua_protobuf_pb_SyncItemLock_set_playerID(lua_State *L);
int lua_protobuf_pb_SyncItemLock_has_playerID(lua_State *L);

// optional bool lock = 3
int lua_protobuf_pb_SyncItemLock_clear_lock(lua_State *L);
int lua_protobuf_pb_SyncItemLock_get_lock(lua_State *L);
int lua_protobuf_pb_SyncItemLock_set_lock(lua_State *L);
int lua_protobuf_pb_SyncItemLock_has_lock(lua_State *L);

// end of message SyncItemLock

// Message OneString
// registers the message type with Lua
int lua_protobuf_pb_OneString_open(lua_State *L);


// push a reference of the message to the Lua stack
// the 3rd and 4th arguments define a callback that can be invoked just before Lua
// garbage collects the message. If the 3rd argument is NULL, Lua will *NOT* free
// memory. If the second argument points to a function, that function is called when
// Lua garbage collects the object. The function is sent a pointer to the message being
// collected and the 4th argument to this function. If the function returns true,
// Lua will free the memory. If false (0), Lua will not free the memory.
void lua_protobuf_pb_OneString_(lua_State *L, ::google::protobuf::Message* msg, bool needDel = true);

// The following functions are called by Lua. Many people will not need them,
// but they are exported for those that do.

// constructor called from Lua
int lua_protobuf_pb_OneString_new(lua_State *L);

// return operation =
int lua_protobuf_pb_OneString_assign(lua_State *L);
// return ::google::Messsage*
int lua_protobuf_pb_OneString_data(lua_State *L);

// obtain instance from a serialized string
int lua_protobuf_pb_OneString_parsefromstring(lua_State *L);

// garbage collects message instance in Lua
int lua_protobuf_pb_OneString_gc(lua_State *L);

// obtain serialized representation of instance
int lua_protobuf_pb_OneString_serialized(lua_State *L);

// clear all fields in the message
int lua_protobuf_pb_OneString_clear(lua_State *L);

// return size of the message
int lua_protobuf_pb_OneString_size(lua_State *L);
// optional string str = 1
int lua_protobuf_pb_OneString_clear_str(lua_State *L);
int lua_protobuf_pb_OneString_get_str(lua_State *L);
int lua_protobuf_pb_OneString_set_str(lua_State *L);
int lua_protobuf_pb_OneString_has_str(lua_State *L);

// end of message OneString

#endif