// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: packetSystem.proto

#ifndef PROTOBUF_packetSystem_2eproto__INCLUDED
#define PROTOBUF_packetSystem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "connectionType.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_packetSystem_2eproto();
void protobuf_AssignDesc_packetSystem_2eproto();
void protobuf_ShutdownFile_packetSystem_2eproto();

class EmptyPacket;
class Update;
class ListenConfig;
class InitServer;
class SetServerInfo;
class InitServerResponse;
class ServerActive;
class InitGate;
class ClientConnectGate;
class ChangeServerGuid;
class GatePlayerCount;
class NewIncomingConnection;
class ConnectionRequestAccepted;
class ConnectionAttemptFailed;
class DisconnectionNotification;
class LoginError;
class FlushConfig;
class ShutServerDown;
class ClockDifferential;
class Bulletin;
class VersionCheck;
class VersionCheckFaild;
class ProxyMessage;
class ReInitProxy;
class PakCheckCodeQuery;
class PakCheckCode;
class PakCheckCodeRes;
class PakCheckFailed;
class InitPveGameServer;
class IncPlayer;
class DeIncPlayer;
class ClientLog;
class ClientDump;
class SystemKeepalive;
class ProxyBalanceAdd;
class ProxyBalanceDel;
class InitUdpProxy;
class PlayerGuidNotify;
class SetPacketStat;
class UploadFileReq;
class UploadFileReply;
class CollectModuleInfo;
class SyncItemLock;
class OneString;

// ===================================================================

class EmptyPacket : public ::google::protobuf::Message {
 public:
  EmptyPacket();
  virtual ~EmptyPacket();

  EmptyPacket(const EmptyPacket& from);

  inline EmptyPacket& operator=(const EmptyPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmptyPacket& default_instance();

  void Swap(EmptyPacket* other);

  // implements Message ----------------------------------------------

  EmptyPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmptyPacket& from);
  void MergeFrom(const EmptyPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.EmptyPacket)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static EmptyPacket* default_instance_;
};
// -------------------------------------------------------------------

class Update : public ::google::protobuf::Message {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  void Swap(Update* other);

  // implements Message ----------------------------------------------

  Update* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 now = 1;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 1;
  inline ::google::protobuf::uint32 now() const;
  inline void set_now(::google::protobuf::uint32 value);

  // optional uint32 delta = 2;
  inline bool has_delta() const;
  inline void clear_delta();
  static const int kDeltaFieldNumber = 2;
  inline ::google::protobuf::uint32 delta() const;
  inline void set_delta(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Update)
 private:
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_delta();
  inline void clear_has_delta();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 now_;
  ::google::protobuf::uint32 delta_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static Update* default_instance_;
};
// -------------------------------------------------------------------

class ListenConfig : public ::google::protobuf::Message {
 public:
  ListenConfig();
  virtual ~ListenConfig();

  ListenConfig(const ListenConfig& from);

  inline ListenConfig& operator=(const ListenConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListenConfig& default_instance();

  void Swap(ListenConfig* other);

  // implements Message ----------------------------------------------

  ListenConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListenConfig& from);
  void MergeFrom(const ListenConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EConnectionType connectionType = 1;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 1;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // optional string listenIP = 2;
  inline bool has_listenip() const;
  inline void clear_listenip();
  static const int kListenIPFieldNumber = 2;
  inline const ::std::string& listenip() const;
  inline void set_listenip(const ::std::string& value);
  inline void set_listenip(const char* value);
  inline void set_listenip(const char* value, size_t size);
  inline ::std::string* mutable_listenip();
  inline ::std::string* release_listenip();
  inline void set_allocated_listenip(::std::string* listenip);

  // optional int32 listenPort = 3;
  inline bool has_listenport() const;
  inline void clear_listenport();
  static const int kListenPortFieldNumber = 3;
  inline ::google::protobuf::int32 listenport() const;
  inline void set_listenport(::google::protobuf::int32 value);

  // optional int32 maxConnection = 4;
  inline bool has_maxconnection() const;
  inline void clear_maxconnection();
  static const int kMaxConnectionFieldNumber = 4;
  inline ::google::protobuf::int32 maxconnection() const;
  inline void set_maxconnection(::google::protobuf::int32 value);

  // optional bool udp = 5 [default = true];
  inline bool has_udp() const;
  inline void clear_udp();
  static const int kUdpFieldNumber = 5;
  inline bool udp() const;
  inline void set_udp(bool value);

  // @@protoc_insertion_point(class_scope:pb.ListenConfig)
 private:
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();
  inline void set_has_listenip();
  inline void clear_has_listenip();
  inline void set_has_listenport();
  inline void clear_has_listenport();
  inline void set_has_maxconnection();
  inline void clear_has_maxconnection();
  inline void set_has_udp();
  inline void clear_has_udp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* listenip_;
  int connectiontype_;
  ::google::protobuf::int32 listenport_;
  ::google::protobuf::int32 maxconnection_;
  bool udp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ListenConfig* default_instance_;
};
// -------------------------------------------------------------------

class InitServer : public ::google::protobuf::Message {
 public:
  InitServer();
  virtual ~InitServer();

  InitServer(const InitServer& from);

  inline InitServer& operator=(const InitServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitServer& default_instance();

  void Swap(InitServer* other);

  // implements Message ----------------------------------------------

  InitServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitServer& from);
  void MergeFrom(const InitServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.ListenConfig servers = 1;
  inline int servers_size() const;
  inline void clear_servers();
  static const int kServersFieldNumber = 1;
  inline const ::pb::ListenConfig& servers(int index) const;
  inline ::pb::ListenConfig* mutable_servers(int index);
  inline ::pb::ListenConfig* add_servers();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
      servers() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
      mutable_servers();

  // repeated .pb.ListenConfig clients = 2;
  inline int clients_size() const;
  inline void clear_clients();
  static const int kClientsFieldNumber = 2;
  inline const ::pb::ListenConfig& clients(int index) const;
  inline ::pb::ListenConfig* mutable_clients(int index);
  inline ::pb::ListenConfig* add_clients();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
      clients() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
      mutable_clients();

  // optional uint32 serverGuid = 3;
  inline bool has_serverguid() const;
  inline void clear_serverguid();
  static const int kServerGuidFieldNumber = 3;
  inline ::google::protobuf::uint32 serverguid() const;
  inline void set_serverguid(::google::protobuf::uint32 value);

  // optional string serverName = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional .pb.EConnectionType connectionType = 5;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 5;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // @@protoc_insertion_point(class_scope:pb.InitServer)
 private:
  inline void set_has_serverguid();
  inline void clear_has_serverguid();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig > servers_;
  ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig > clients_;
  ::std::string* servername_;
  ::google::protobuf::uint32 serverguid_;
  int connectiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static InitServer* default_instance_;
};
// -------------------------------------------------------------------

class SetServerInfo : public ::google::protobuf::Message {
 public:
  SetServerInfo();
  virtual ~SetServerInfo();

  SetServerInfo(const SetServerInfo& from);

  inline SetServerInfo& operator=(const SetServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetServerInfo& default_instance();

  void Swap(SetServerInfo* other);

  // implements Message ----------------------------------------------

  SetServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetServerInfo& from);
  void MergeFrom(const SetServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 serverGuid = 1;
  inline bool has_serverguid() const;
  inline void clear_serverguid();
  static const int kServerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 serverguid() const;
  inline void set_serverguid(::google::protobuf::uint32 value);

  // optional string serverName = 2;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 2;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 maxPlayerCount = 4;
  inline bool has_maxplayercount() const;
  inline void clear_maxplayercount();
  static const int kMaxPlayerCountFieldNumber = 4;
  inline ::google::protobuf::int32 maxplayercount() const;
  inline void set_maxplayercount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.SetServerInfo)
 private:
  inline void set_has_serverguid();
  inline void clear_has_serverguid();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_maxplayercount();
  inline void clear_has_maxplayercount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* servername_;
  ::google::protobuf::uint32 serverguid_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maxplayercount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static SetServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class InitServerResponse : public ::google::protobuf::Message {
 public:
  InitServerResponse();
  virtual ~InitServerResponse();

  InitServerResponse(const InitServerResponse& from);

  inline InitServerResponse& operator=(const InitServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitServerResponse& default_instance();

  void Swap(InitServerResponse* other);

  // implements Message ----------------------------------------------

  InitServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitServerResponse& from);
  void MergeFrom(const InitServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.ListenConfig remoteServers = 1;
  inline int remoteservers_size() const;
  inline void clear_remoteservers();
  static const int kRemoteServersFieldNumber = 1;
  inline const ::pb::ListenConfig& remoteservers(int index) const;
  inline ::pb::ListenConfig* mutable_remoteservers(int index);
  inline ::pb::ListenConfig* add_remoteservers();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
      remoteservers() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
      mutable_remoteservers();

  // @@protoc_insertion_point(class_scope:pb.InitServerResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig > remoteservers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static InitServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerActive : public ::google::protobuf::Message {
 public:
  ServerActive();
  virtual ~ServerActive();

  ServerActive(const ServerActive& from);

  inline ServerActive& operator=(const ServerActive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerActive& default_instance();

  void Swap(ServerActive* other);

  // implements Message ----------------------------------------------

  ServerActive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerActive& from);
  void MergeFrom(const ServerActive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ListenConfig remoteServer = 1;
  inline bool has_remoteserver() const;
  inline void clear_remoteserver();
  static const int kRemoteServerFieldNumber = 1;
  inline const ::pb::ListenConfig& remoteserver() const;
  inline ::pb::ListenConfig* mutable_remoteserver();
  inline ::pb::ListenConfig* release_remoteserver();
  inline void set_allocated_remoteserver(::pb::ListenConfig* remoteserver);

  // @@protoc_insertion_point(class_scope:pb.ServerActive)
 private:
  inline void set_has_remoteserver();
  inline void clear_has_remoteserver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ListenConfig* remoteserver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ServerActive* default_instance_;
};
// -------------------------------------------------------------------

class InitGate : public ::google::protobuf::Message {
 public:
  InitGate();
  virtual ~InitGate();

  InitGate(const InitGate& from);

  inline InitGate& operator=(const InitGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitGate& default_instance();

  void Swap(InitGate* other);

  // implements Message ----------------------------------------------

  InitGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitGate& from);
  void MergeFrom(const InitGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gateAddress = 1;
  inline bool has_gateaddress() const;
  inline void clear_gateaddress();
  static const int kGateAddressFieldNumber = 1;
  inline const ::std::string& gateaddress() const;
  inline void set_gateaddress(const ::std::string& value);
  inline void set_gateaddress(const char* value);
  inline void set_gateaddress(const char* value, size_t size);
  inline ::std::string* mutable_gateaddress();
  inline ::std::string* release_gateaddress();
  inline void set_allocated_gateaddress(::std::string* gateaddress);

  // optional int32 gatePort = 2;
  inline bool has_gateport() const;
  inline void clear_gateport();
  static const int kGatePortFieldNumber = 2;
  inline ::google::protobuf::int32 gateport() const;
  inline void set_gateport(::google::protobuf::int32 value);

  // optional uint32 gateGuid = 3;
  inline bool has_gateguid() const;
  inline void clear_gateguid();
  static const int kGateGuidFieldNumber = 3;
  inline ::google::protobuf::uint32 gateguid() const;
  inline void set_gateguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.InitGate)
 private:
  inline void set_has_gateaddress();
  inline void clear_has_gateaddress();
  inline void set_has_gateport();
  inline void clear_has_gateport();
  inline void set_has_gateguid();
  inline void clear_has_gateguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gateaddress_;
  ::google::protobuf::int32 gateport_;
  ::google::protobuf::uint32 gateguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static InitGate* default_instance_;
};
// -------------------------------------------------------------------

class ClientConnectGate : public ::google::protobuf::Message {
 public:
  ClientConnectGate();
  virtual ~ClientConnectGate();

  ClientConnectGate(const ClientConnectGate& from);

  inline ClientConnectGate& operator=(const ClientConnectGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConnectGate& default_instance();

  void Swap(ClientConnectGate* other);

  // implements Message ----------------------------------------------

  ClientConnectGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientConnectGate& from);
  void MergeFrom(const ClientConnectGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gateAddress = 1;
  inline bool has_gateaddress() const;
  inline void clear_gateaddress();
  static const int kGateAddressFieldNumber = 1;
  inline const ::std::string& gateaddress() const;
  inline void set_gateaddress(const ::std::string& value);
  inline void set_gateaddress(const char* value);
  inline void set_gateaddress(const char* value, size_t size);
  inline ::std::string* mutable_gateaddress();
  inline ::std::string* release_gateaddress();
  inline void set_allocated_gateaddress(::std::string* gateaddress);

  // optional int32 gatePort = 2;
  inline bool has_gateport() const;
  inline void clear_gateport();
  static const int kGatePortFieldNumber = 2;
  inline ::google::protobuf::int32 gateport() const;
  inline void set_gateport(::google::protobuf::int32 value);

  // optional uint32 newGuid = 3;
  inline bool has_newguid() const;
  inline void clear_newguid();
  static const int kNewGuidFieldNumber = 3;
  inline ::google::protobuf::uint32 newguid() const;
  inline void set_newguid(::google::protobuf::uint32 value);

  // optional uint32 waitNum = 4;
  inline bool has_waitnum() const;
  inline void clear_waitnum();
  static const int kWaitNumFieldNumber = 4;
  inline ::google::protobuf::uint32 waitnum() const;
  inline void set_waitnum(::google::protobuf::uint32 value);

  // optional bytes securityKey = 5;
  inline bool has_securitykey() const;
  inline void clear_securitykey();
  static const int kSecurityKeyFieldNumber = 5;
  inline const ::std::string& securitykey() const;
  inline void set_securitykey(const ::std::string& value);
  inline void set_securitykey(const char* value);
  inline void set_securitykey(const void* value, size_t size);
  inline ::std::string* mutable_securitykey();
  inline ::std::string* release_securitykey();
  inline void set_allocated_securitykey(::std::string* securitykey);

  // @@protoc_insertion_point(class_scope:pb.ClientConnectGate)
 private:
  inline void set_has_gateaddress();
  inline void clear_has_gateaddress();
  inline void set_has_gateport();
  inline void clear_has_gateport();
  inline void set_has_newguid();
  inline void clear_has_newguid();
  inline void set_has_waitnum();
  inline void clear_has_waitnum();
  inline void set_has_securitykey();
  inline void clear_has_securitykey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gateaddress_;
  ::google::protobuf::int32 gateport_;
  ::google::protobuf::uint32 newguid_;
  ::std::string* securitykey_;
  ::google::protobuf::uint32 waitnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ClientConnectGate* default_instance_;
};
// -------------------------------------------------------------------

class ChangeServerGuid : public ::google::protobuf::Message {
 public:
  ChangeServerGuid();
  virtual ~ChangeServerGuid();

  ChangeServerGuid(const ChangeServerGuid& from);

  inline ChangeServerGuid& operator=(const ChangeServerGuid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeServerGuid& default_instance();

  void Swap(ChangeServerGuid* other);

  // implements Message ----------------------------------------------

  ChangeServerGuid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeServerGuid& from);
  void MergeFrom(const ChangeServerGuid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 newGuid = 1;
  inline bool has_newguid() const;
  inline void clear_newguid();
  static const int kNewGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 newguid() const;
  inline void set_newguid(::google::protobuf::uint32 value);

  // optional uint32 serverGuid = 2;
  inline bool has_serverguid() const;
  inline void clear_serverguid();
  static const int kServerGuidFieldNumber = 2;
  inline ::google::protobuf::uint32 serverguid() const;
  inline void set_serverguid(::google::protobuf::uint32 value);

  // optional uint32 groupID = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIDFieldNumber = 3;
  inline ::google::protobuf::uint32 groupid() const;
  inline void set_groupid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ChangeServerGuid)
 private:
  inline void set_has_newguid();
  inline void clear_has_newguid();
  inline void set_has_serverguid();
  inline void clear_has_serverguid();
  inline void set_has_groupid();
  inline void clear_has_groupid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 newguid_;
  ::google::protobuf::uint32 serverguid_;
  ::google::protobuf::uint32 groupid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ChangeServerGuid* default_instance_;
};
// -------------------------------------------------------------------

class GatePlayerCount : public ::google::protobuf::Message {
 public:
  GatePlayerCount();
  virtual ~GatePlayerCount();

  GatePlayerCount(const GatePlayerCount& from);

  inline GatePlayerCount& operator=(const GatePlayerCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GatePlayerCount& default_instance();

  void Swap(GatePlayerCount* other);

  // implements Message ----------------------------------------------

  GatePlayerCount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GatePlayerCount& from);
  void MergeFrom(const GatePlayerCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gateGuid = 1;
  inline bool has_gateguid() const;
  inline void clear_gateguid();
  static const int kGateGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 gateguid() const;
  inline void set_gateguid(::google::protobuf::uint32 value);

  // optional int32 playerCount = 2;
  inline bool has_playercount() const;
  inline void clear_playercount();
  static const int kPlayerCountFieldNumber = 2;
  inline ::google::protobuf::int32 playercount() const;
  inline void set_playercount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.GatePlayerCount)
 private:
  inline void set_has_gateguid();
  inline void clear_has_gateguid();
  inline void set_has_playercount();
  inline void clear_has_playercount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gateguid_;
  ::google::protobuf::int32 playercount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static GatePlayerCount* default_instance_;
};
// -------------------------------------------------------------------

class NewIncomingConnection : public ::google::protobuf::Message {
 public:
  NewIncomingConnection();
  virtual ~NewIncomingConnection();

  NewIncomingConnection(const NewIncomingConnection& from);

  inline NewIncomingConnection& operator=(const NewIncomingConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewIncomingConnection& default_instance();

  void Swap(NewIncomingConnection* other);

  // implements Message ----------------------------------------------

  NewIncomingConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewIncomingConnection& from);
  void MergeFrom(const NewIncomingConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EConnectionType connectionType = 1;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 1;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // optional uint32 remoteGuid = 2;
  inline bool has_remoteguid() const;
  inline void clear_remoteguid();
  static const int kRemoteGuidFieldNumber = 2;
  inline ::google::protobuf::uint32 remoteguid() const;
  inline void set_remoteguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.NewIncomingConnection)
 private:
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();
  inline void set_has_remoteguid();
  inline void clear_has_remoteguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int connectiontype_;
  ::google::protobuf::uint32 remoteguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static NewIncomingConnection* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionRequestAccepted : public ::google::protobuf::Message {
 public:
  ConnectionRequestAccepted();
  virtual ~ConnectionRequestAccepted();

  ConnectionRequestAccepted(const ConnectionRequestAccepted& from);

  inline ConnectionRequestAccepted& operator=(const ConnectionRequestAccepted& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionRequestAccepted& default_instance();

  void Swap(ConnectionRequestAccepted* other);

  // implements Message ----------------------------------------------

  ConnectionRequestAccepted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionRequestAccepted& from);
  void MergeFrom(const ConnectionRequestAccepted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EConnectionType connectionType = 1;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 1;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // optional uint32 remoteGuid = 2;
  inline bool has_remoteguid() const;
  inline void clear_remoteguid();
  static const int kRemoteGuidFieldNumber = 2;
  inline ::google::protobuf::uint32 remoteguid() const;
  inline void set_remoteguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ConnectionRequestAccepted)
 private:
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();
  inline void set_has_remoteguid();
  inline void clear_has_remoteguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int connectiontype_;
  ::google::protobuf::uint32 remoteguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ConnectionRequestAccepted* default_instance_;
};
// -------------------------------------------------------------------

class ConnectionAttemptFailed : public ::google::protobuf::Message {
 public:
  ConnectionAttemptFailed();
  virtual ~ConnectionAttemptFailed();

  ConnectionAttemptFailed(const ConnectionAttemptFailed& from);

  inline ConnectionAttemptFailed& operator=(const ConnectionAttemptFailed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectionAttemptFailed& default_instance();

  void Swap(ConnectionAttemptFailed* other);

  // implements Message ----------------------------------------------

  ConnectionAttemptFailed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectionAttemptFailed& from);
  void MergeFrom(const ConnectionAttemptFailed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 remoteGuid = 1;
  inline bool has_remoteguid() const;
  inline void clear_remoteguid();
  static const int kRemoteGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 remoteguid() const;
  inline void set_remoteguid(::google::protobuf::uint32 value);

  // optional string IP = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIPFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional .pb.EConnectionType connectionType = 4;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 4;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // @@protoc_insertion_point(class_scope:pb.ConnectionAttemptFailed)
 private:
  inline void set_has_remoteguid();
  inline void clear_has_remoteguid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ip_;
  ::google::protobuf::uint32 remoteguid_;
  ::google::protobuf::int32 port_;
  int connectiontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ConnectionAttemptFailed* default_instance_;
};
// -------------------------------------------------------------------

class DisconnectionNotification : public ::google::protobuf::Message {
 public:
  DisconnectionNotification();
  virtual ~DisconnectionNotification();

  DisconnectionNotification(const DisconnectionNotification& from);

  inline DisconnectionNotification& operator=(const DisconnectionNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectionNotification& default_instance();

  void Swap(DisconnectionNotification* other);

  // implements Message ----------------------------------------------

  DisconnectionNotification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisconnectionNotification& from);
  void MergeFrom(const DisconnectionNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.EConnectionType connectionType = 1;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectionTypeFieldNumber = 1;
  inline ::pb::EConnectionType connectiontype() const;
  inline void set_connectiontype(::pb::EConnectionType value);

  // optional uint32 remoteGuid = 2;
  inline bool has_remoteguid() const;
  inline void clear_remoteguid();
  static const int kRemoteGuidFieldNumber = 2;
  inline ::google::protobuf::uint32 remoteguid() const;
  inline void set_remoteguid(::google::protobuf::uint32 value);

  // optional bool bPassive = 3 [default = false];
  inline bool has_bpassive() const;
  inline void clear_bpassive();
  static const int kBPassiveFieldNumber = 3;
  inline bool bpassive() const;
  inline void set_bpassive(bool value);

  // @@protoc_insertion_point(class_scope:pb.DisconnectionNotification)
 private:
  inline void set_has_connectiontype();
  inline void clear_has_connectiontype();
  inline void set_has_remoteguid();
  inline void clear_has_remoteguid();
  inline void set_has_bpassive();
  inline void clear_has_bpassive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int connectiontype_;
  ::google::protobuf::uint32 remoteguid_;
  bool bpassive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static DisconnectionNotification* default_instance_;
};
// -------------------------------------------------------------------

class LoginError : public ::google::protobuf::Message {
 public:
  LoginError();
  virtual ~LoginError();

  LoginError(const LoginError& from);

  inline LoginError& operator=(const LoginError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginError& default_instance();

  void Swap(LoginError* other);

  // implements Message ----------------------------------------------

  LoginError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginError& from);
  void MergeFrom(const LoginError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerGuid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.LoginError)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static LoginError* default_instance_;
};
// -------------------------------------------------------------------

class FlushConfig : public ::google::protobuf::Message {
 public:
  FlushConfig();
  virtual ~FlushConfig();

  FlushConfig(const FlushConfig& from);

  inline FlushConfig& operator=(const FlushConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlushConfig& default_instance();

  void Swap(FlushConfig* other);

  // implements Message ----------------------------------------------

  FlushConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlushConfig& from);
  void MergeFrom(const FlushConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string flushModule = 1;
  inline bool has_flushmodule() const;
  inline void clear_flushmodule();
  static const int kFlushModuleFieldNumber = 1;
  inline const ::std::string& flushmodule() const;
  inline void set_flushmodule(const ::std::string& value);
  inline void set_flushmodule(const char* value);
  inline void set_flushmodule(const char* value, size_t size);
  inline ::std::string* mutable_flushmodule();
  inline ::std::string* release_flushmodule();
  inline void set_allocated_flushmodule(::std::string* flushmodule);

  // @@protoc_insertion_point(class_scope:pb.FlushConfig)
 private:
  inline void set_has_flushmodule();
  inline void clear_has_flushmodule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* flushmodule_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static FlushConfig* default_instance_;
};
// -------------------------------------------------------------------

class ShutServerDown : public ::google::protobuf::Message {
 public:
  ShutServerDown();
  virtual ~ShutServerDown();

  ShutServerDown(const ShutServerDown& from);

  inline ShutServerDown& operator=(const ShutServerDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutServerDown& default_instance();

  void Swap(ShutServerDown* other);

  // implements Message ----------------------------------------------

  ShutServerDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShutServerDown& from);
  void MergeFrom(const ShutServerDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 afterTime = 1;
  inline bool has_aftertime() const;
  inline void clear_aftertime();
  static const int kAfterTimeFieldNumber = 1;
  inline ::google::protobuf::int32 aftertime() const;
  inline void set_aftertime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.ShutServerDown)
 private:
  inline void set_has_aftertime();
  inline void clear_has_aftertime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 aftertime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ShutServerDown* default_instance_;
};
// -------------------------------------------------------------------

class ClockDifferential : public ::google::protobuf::Message {
 public:
  ClockDifferential();
  virtual ~ClockDifferential();

  ClockDifferential(const ClockDifferential& from);

  inline ClockDifferential& operator=(const ClockDifferential& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClockDifferential& default_instance();

  void Swap(ClockDifferential* other);

  // implements Message ----------------------------------------------

  ClockDifferential* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClockDifferential& from);
  void MergeFrom(const ClockDifferential& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 beginTime = 1;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBeginTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 begintime() const;
  inline void set_begintime(::google::protobuf::uint32 value);

  // optional uint32 syncTime = 2;
  inline bool has_synctime() const;
  inline void clear_synctime();
  static const int kSyncTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 synctime() const;
  inline void set_synctime(::google::protobuf::uint32 value);

  // optional uint32 guid = 3;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 3;
  inline ::google::protobuf::uint32 guid() const;
  inline void set_guid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ClockDifferential)
 private:
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_synctime();
  inline void clear_has_synctime();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 begintime_;
  ::google::protobuf::uint32 synctime_;
  ::google::protobuf::uint32 guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ClockDifferential* default_instance_;
};
// -------------------------------------------------------------------

class Bulletin : public ::google::protobuf::Message {
 public:
  Bulletin();
  virtual ~Bulletin();

  Bulletin(const Bulletin& from);

  inline Bulletin& operator=(const Bulletin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bulletin& default_instance();

  void Swap(Bulletin* other);

  // implements Message ----------------------------------------------

  Bulletin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bulletin& from);
  void MergeFrom(const Bulletin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string content = 1;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 1;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:pb.Bulletin)
 private:
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static Bulletin* default_instance_;
};
// -------------------------------------------------------------------

class VersionCheck : public ::google::protobuf::Message {
 public:
  VersionCheck();
  virtual ~VersionCheck();

  VersionCheck(const VersionCheck& from);

  inline VersionCheck& operator=(const VersionCheck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionCheck& default_instance();

  void Swap(VersionCheck* other);

  // implements Message ----------------------------------------------

  VersionCheck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionCheck& from);
  void MergeFrom(const VersionCheck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional uint32 guid = 2;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 2;
  inline ::google::protobuf::uint32 guid() const;
  inline void set_guid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.VersionCheck)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_guid();
  inline void clear_has_guid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;
  ::google::protobuf::uint32 guid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static VersionCheck* default_instance_;
};
// -------------------------------------------------------------------

class VersionCheckFaild : public ::google::protobuf::Message {
 public:
  VersionCheckFaild();
  virtual ~VersionCheckFaild();

  VersionCheckFaild(const VersionCheckFaild& from);

  inline VersionCheckFaild& operator=(const VersionCheckFaild& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionCheckFaild& default_instance();

  void Swap(VersionCheckFaild* other);

  // implements Message ----------------------------------------------

  VersionCheckFaild* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionCheckFaild& from);
  void MergeFrom(const VersionCheckFaild& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.VersionCheckFaild)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static VersionCheckFaild* default_instance_;
};
// -------------------------------------------------------------------

class ProxyMessage : public ::google::protobuf::Message {
 public:
  ProxyMessage();
  virtual ~ProxyMessage();

  ProxyMessage(const ProxyMessage& from);

  inline ProxyMessage& operator=(const ProxyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyMessage& default_instance();

  void Swap(ProxyMessage* other);

  // implements Message ----------------------------------------------

  ProxyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProxyMessage& from);
  void MergeFrom(const ProxyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerGuid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint32 value);

  // optional bool status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline bool status() const;
  inline void set_status(bool value);

  // @@protoc_insertion_point(class_scope:pb.ProxyMessage)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 playerguid_;
  bool status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ProxyMessage* default_instance_;
};
// -------------------------------------------------------------------

class ReInitProxy : public ::google::protobuf::Message {
 public:
  ReInitProxy();
  virtual ~ReInitProxy();

  ReInitProxy(const ReInitProxy& from);

  inline ReInitProxy& operator=(const ReInitProxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReInitProxy& default_instance();

  void Swap(ReInitProxy* other);

  // implements Message ----------------------------------------------

  ReInitProxy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReInitProxy& from);
  void MergeFrom(const ReInitProxy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.ReInitProxy)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ReInitProxy* default_instance_;
};
// -------------------------------------------------------------------

class PakCheckCodeQuery : public ::google::protobuf::Message {
 public:
  PakCheckCodeQuery();
  virtual ~PakCheckCodeQuery();

  PakCheckCodeQuery(const PakCheckCodeQuery& from);

  inline PakCheckCodeQuery& operator=(const PakCheckCodeQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PakCheckCodeQuery& default_instance();

  void Swap(PakCheckCodeQuery* other);

  // implements Message ----------------------------------------------

  PakCheckCodeQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PakCheckCodeQuery& from);
  void MergeFrom(const PakCheckCodeQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:pb.PakCheckCodeQuery)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static PakCheckCodeQuery* default_instance_;
};
// -------------------------------------------------------------------

class PakCheckCode : public ::google::protobuf::Message {
 public:
  PakCheckCode();
  virtual ~PakCheckCode();

  PakCheckCode(const PakCheckCode& from);

  inline PakCheckCode& operator=(const PakCheckCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PakCheckCode& default_instance();

  void Swap(PakCheckCode* other);

  // implements Message ----------------------------------------------

  PakCheckCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PakCheckCode& from);
  void MergeFrom(const PakCheckCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pakName = 1;
  inline bool has_pakname() const;
  inline void clear_pakname();
  static const int kPakNameFieldNumber = 1;
  inline const ::std::string& pakname() const;
  inline void set_pakname(const ::std::string& value);
  inline void set_pakname(const char* value);
  inline void set_pakname(const char* value, size_t size);
  inline ::std::string* mutable_pakname();
  inline ::std::string* release_pakname();
  inline void set_allocated_pakname(::std::string* pakname);

  // optional string checkCode = 2;
  inline bool has_checkcode() const;
  inline void clear_checkcode();
  static const int kCheckCodeFieldNumber = 2;
  inline const ::std::string& checkcode() const;
  inline void set_checkcode(const ::std::string& value);
  inline void set_checkcode(const char* value);
  inline void set_checkcode(const char* value, size_t size);
  inline ::std::string* mutable_checkcode();
  inline ::std::string* release_checkcode();
  inline void set_allocated_checkcode(::std::string* checkcode);

  // @@protoc_insertion_point(class_scope:pb.PakCheckCode)
 private:
  inline void set_has_pakname();
  inline void clear_has_pakname();
  inline void set_has_checkcode();
  inline void clear_has_checkcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pakname_;
  ::std::string* checkcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static PakCheckCode* default_instance_;
};
// -------------------------------------------------------------------

class PakCheckCodeRes : public ::google::protobuf::Message {
 public:
  PakCheckCodeRes();
  virtual ~PakCheckCodeRes();

  PakCheckCodeRes(const PakCheckCodeRes& from);

  inline PakCheckCodeRes& operator=(const PakCheckCodeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PakCheckCodeRes& default_instance();

  void Swap(PakCheckCodeRes* other);

  // implements Message ----------------------------------------------

  PakCheckCodeRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PakCheckCodeRes& from);
  void MergeFrom(const PakCheckCodeRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.PakCheckCode pakCheckCodes = 1;
  inline int pakcheckcodes_size() const;
  inline void clear_pakcheckcodes();
  static const int kPakCheckCodesFieldNumber = 1;
  inline const ::pb::PakCheckCode& pakcheckcodes(int index) const;
  inline ::pb::PakCheckCode* mutable_pakcheckcodes(int index);
  inline ::pb::PakCheckCode* add_pakcheckcodes();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::PakCheckCode >&
      pakcheckcodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::PakCheckCode >*
      mutable_pakcheckcodes();

  // @@protoc_insertion_point(class_scope:pb.PakCheckCodeRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::PakCheckCode > pakcheckcodes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static PakCheckCodeRes* default_instance_;
};
// -------------------------------------------------------------------

class PakCheckFailed : public ::google::protobuf::Message {
 public:
  PakCheckFailed();
  virtual ~PakCheckFailed();

  PakCheckFailed(const PakCheckFailed& from);

  inline PakCheckFailed& operator=(const PakCheckFailed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PakCheckFailed& default_instance();

  void Swap(PakCheckFailed* other);

  // implements Message ----------------------------------------------

  PakCheckFailed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PakCheckFailed& from);
  void MergeFrom(const PakCheckFailed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string pakNames = 1;
  inline int paknames_size() const;
  inline void clear_paknames();
  static const int kPakNamesFieldNumber = 1;
  inline const ::std::string& paknames(int index) const;
  inline ::std::string* mutable_paknames(int index);
  inline void set_paknames(int index, const ::std::string& value);
  inline void set_paknames(int index, const char* value);
  inline void set_paknames(int index, const char* value, size_t size);
  inline ::std::string* add_paknames();
  inline void add_paknames(const ::std::string& value);
  inline void add_paknames(const char* value);
  inline void add_paknames(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& paknames() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_paknames();

  // @@protoc_insertion_point(class_scope:pb.PakCheckFailed)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> paknames_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static PakCheckFailed* default_instance_;
};
// -------------------------------------------------------------------

class InitPveGameServer : public ::google::protobuf::Message {
 public:
  InitPveGameServer();
  virtual ~InitPveGameServer();

  InitPveGameServer(const InitPveGameServer& from);

  inline InitPveGameServer& operator=(const InitPveGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitPveGameServer& default_instance();

  void Swap(InitPveGameServer* other);

  // implements Message ----------------------------------------------

  InitPveGameServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitPveGameServer& from);
  void MergeFrom(const InitPveGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 maxPlayerCount = 1;
  inline bool has_maxplayercount() const;
  inline void clear_maxplayercount();
  static const int kMaxPlayerCountFieldNumber = 1;
  inline ::google::protobuf::int32 maxplayercount() const;
  inline void set_maxplayercount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.InitPveGameServer)
 private:
  inline void set_has_maxplayercount();
  inline void clear_has_maxplayercount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 maxplayercount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static InitPveGameServer* default_instance_;
};
// -------------------------------------------------------------------

class IncPlayer : public ::google::protobuf::Message {
 public:
  IncPlayer();
  virtual ~IncPlayer();

  IncPlayer(const IncPlayer& from);

  inline IncPlayer& operator=(const IncPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IncPlayer& default_instance();

  void Swap(IncPlayer* other);

  // implements Message ----------------------------------------------

  IncPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IncPlayer& from);
  void MergeFrom(const IncPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerGuid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.IncPlayer)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static IncPlayer* default_instance_;
};
// -------------------------------------------------------------------

class DeIncPlayer : public ::google::protobuf::Message {
 public:
  DeIncPlayer();
  virtual ~DeIncPlayer();

  DeIncPlayer(const DeIncPlayer& from);

  inline DeIncPlayer& operator=(const DeIncPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeIncPlayer& default_instance();

  void Swap(DeIncPlayer* other);

  // implements Message ----------------------------------------------

  DeIncPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeIncPlayer& from);
  void MergeFrom(const DeIncPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.DeIncPlayer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static DeIncPlayer* default_instance_;
};
// -------------------------------------------------------------------

class ClientLog : public ::google::protobuf::Message {
 public:
  ClientLog();
  virtual ~ClientLog();

  ClientLog(const ClientLog& from);

  inline ClientLog& operator=(const ClientLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLog& default_instance();

  void Swap(ClientLog* other);

  // implements Message ----------------------------------------------

  ClientLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLog& from);
  void MergeFrom(const ClientLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline bool error() const;
  inline void set_error(bool value);

  // required string machineID = 2;
  inline bool has_machineid() const;
  inline void clear_machineid();
  static const int kMachineIDFieldNumber = 2;
  inline const ::std::string& machineid() const;
  inline void set_machineid(const ::std::string& value);
  inline void set_machineid(const char* value);
  inline void set_machineid(const char* value, size_t size);
  inline ::std::string* mutable_machineid();
  inline ::std::string* release_machineid();
  inline void set_allocated_machineid(::std::string* machineid);

  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // required string memoryStatus = 4;
  inline bool has_memorystatus() const;
  inline void clear_memorystatus();
  static const int kMemoryStatusFieldNumber = 4;
  inline const ::std::string& memorystatus() const;
  inline void set_memorystatus(const ::std::string& value);
  inline void set_memorystatus(const char* value);
  inline void set_memorystatus(const char* value, size_t size);
  inline ::std::string* mutable_memorystatus();
  inline ::std::string* release_memorystatus();
  inline void set_allocated_memorystatus(::std::string* memorystatus);

  // @@protoc_insertion_point(class_scope:pb.ClientLog)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_machineid();
  inline void clear_has_machineid();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_memorystatus();
  inline void clear_has_memorystatus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* machineid_;
  ::std::string* content_;
  ::std::string* memorystatus_;
  bool error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ClientLog* default_instance_;
};
// -------------------------------------------------------------------

class ClientDump : public ::google::protobuf::Message {
 public:
  ClientDump();
  virtual ~ClientDump();

  ClientDump(const ClientDump& from);

  inline ClientDump& operator=(const ClientDump& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientDump& default_instance();

  void Swap(ClientDump* other);

  // implements Message ----------------------------------------------

  ClientDump* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientDump& from);
  void MergeFrom(const ClientDump& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string machineID = 1;
  inline bool has_machineid() const;
  inline void clear_machineid();
  static const int kMachineIDFieldNumber = 1;
  inline const ::std::string& machineid() const;
  inline void set_machineid(const ::std::string& value);
  inline void set_machineid(const char* value);
  inline void set_machineid(const char* value, size_t size);
  inline ::std::string* mutable_machineid();
  inline ::std::string* release_machineid();
  inline void set_allocated_machineid(::std::string* machineid);

  // required string dumpName = 2;
  inline bool has_dumpname() const;
  inline void clear_dumpname();
  static const int kDumpNameFieldNumber = 2;
  inline const ::std::string& dumpname() const;
  inline void set_dumpname(const ::std::string& value);
  inline void set_dumpname(const char* value);
  inline void set_dumpname(const char* value, size_t size);
  inline ::std::string* mutable_dumpname();
  inline ::std::string* release_dumpname();
  inline void set_allocated_dumpname(::std::string* dumpname);

  // required bytes dumpContent = 3;
  inline bool has_dumpcontent() const;
  inline void clear_dumpcontent();
  static const int kDumpContentFieldNumber = 3;
  inline const ::std::string& dumpcontent() const;
  inline void set_dumpcontent(const ::std::string& value);
  inline void set_dumpcontent(const char* value);
  inline void set_dumpcontent(const void* value, size_t size);
  inline ::std::string* mutable_dumpcontent();
  inline ::std::string* release_dumpcontent();
  inline void set_allocated_dumpcontent(::std::string* dumpcontent);

  // required string memoryStatus = 4;
  inline bool has_memorystatus() const;
  inline void clear_memorystatus();
  static const int kMemoryStatusFieldNumber = 4;
  inline const ::std::string& memorystatus() const;
  inline void set_memorystatus(const ::std::string& value);
  inline void set_memorystatus(const char* value);
  inline void set_memorystatus(const char* value, size_t size);
  inline ::std::string* mutable_memorystatus();
  inline ::std::string* release_memorystatus();
  inline void set_allocated_memorystatus(::std::string* memorystatus);

  // @@protoc_insertion_point(class_scope:pb.ClientDump)
 private:
  inline void set_has_machineid();
  inline void clear_has_machineid();
  inline void set_has_dumpname();
  inline void clear_has_dumpname();
  inline void set_has_dumpcontent();
  inline void clear_has_dumpcontent();
  inline void set_has_memorystatus();
  inline void clear_has_memorystatus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* machineid_;
  ::std::string* dumpname_;
  ::std::string* dumpcontent_;
  ::std::string* memorystatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ClientDump* default_instance_;
};
// -------------------------------------------------------------------

class SystemKeepalive : public ::google::protobuf::Message {
 public:
  SystemKeepalive();
  virtual ~SystemKeepalive();

  SystemKeepalive(const SystemKeepalive& from);

  inline SystemKeepalive& operator=(const SystemKeepalive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemKeepalive& default_instance();

  void Swap(SystemKeepalive* other);

  // implements Message ----------------------------------------------

  SystemKeepalive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemKeepalive& from);
  void MergeFrom(const SystemKeepalive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pb.SystemKeepalive)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static SystemKeepalive* default_instance_;
};
// -------------------------------------------------------------------

class ProxyBalanceAdd : public ::google::protobuf::Message {
 public:
  ProxyBalanceAdd();
  virtual ~ProxyBalanceAdd();

  ProxyBalanceAdd(const ProxyBalanceAdd& from);

  inline ProxyBalanceAdd& operator=(const ProxyBalanceAdd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyBalanceAdd& default_instance();

  void Swap(ProxyBalanceAdd* other);

  // implements Message ----------------------------------------------

  ProxyBalanceAdd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProxyBalanceAdd& from);
  void MergeFrom(const ProxyBalanceAdd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerGuid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ProxyBalanceAdd)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ProxyBalanceAdd* default_instance_;
};
// -------------------------------------------------------------------

class ProxyBalanceDel : public ::google::protobuf::Message {
 public:
  ProxyBalanceDel();
  virtual ~ProxyBalanceDel();

  ProxyBalanceDel(const ProxyBalanceDel& from);

  inline ProxyBalanceDel& operator=(const ProxyBalanceDel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProxyBalanceDel& default_instance();

  void Swap(ProxyBalanceDel* other);

  // implements Message ----------------------------------------------

  ProxyBalanceDel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProxyBalanceDel& from);
  void MergeFrom(const ProxyBalanceDel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerGuid = 1;
  inline bool has_playerguid() const;
  inline void clear_playerguid();
  static const int kPlayerGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 playerguid() const;
  inline void set_playerguid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.ProxyBalanceDel)
 private:
  inline void set_has_playerguid();
  inline void clear_has_playerguid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 playerguid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static ProxyBalanceDel* default_instance_;
};
// -------------------------------------------------------------------

class InitUdpProxy : public ::google::protobuf::Message {
 public:
  InitUdpProxy();
  virtual ~InitUdpProxy();

  InitUdpProxy(const InitUdpProxy& from);

  inline InitUdpProxy& operator=(const InitUdpProxy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitUdpProxy& default_instance();

  void Swap(InitUdpProxy* other);

  // implements Message ----------------------------------------------

  InitUdpProxy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitUdpProxy& from);
  void MergeFrom(const InitUdpProxy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string udpProxyHost = 1;
  inline bool has_udpproxyhost() const;
  inline void clear_udpproxyhost();
  static const int kUdpProxyHostFieldNumber = 1;
  inline const ::std::string& udpproxyhost() const;
  inline void set_udpproxyhost(const ::std::string& value);
  inline void set_udpproxyhost(const char* value);
  inline void set_udpproxyhost(const char* value, size_t size);
  inline ::std::string* mutable_udpproxyhost();
  inline ::std::string* release_udpproxyhost();
  inline void set_allocated_udpproxyhost(::std::string* udpproxyhost);

  // optional int32 udpProxyPort = 2;
  inline bool has_udpproxyport() const;
  inline void clear_udpproxyport();
  static const int kUdpProxyPortFieldNumber = 2;
  inline ::google::protobuf::int32 udpproxyport() const;
  inline void set_udpproxyport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.InitUdpProxy)
 private:
  inline void set_has_udpproxyhost();
  inline void clear_has_udpproxyhost();
  inline void set_has_udpproxyport();
  inline void clear_has_udpproxyport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* udpproxyhost_;
  ::google::protobuf::int32 udpproxyport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static InitUdpProxy* default_instance_;
};
// -------------------------------------------------------------------

class PlayerGuidNotify : public ::google::protobuf::Message {
 public:
  PlayerGuidNotify();
  virtual ~PlayerGuidNotify();

  PlayerGuidNotify(const PlayerGuidNotify& from);

  inline PlayerGuidNotify& operator=(const PlayerGuidNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerGuidNotify& default_instance();

  void Swap(PlayerGuidNotify* other);

  // implements Message ----------------------------------------------

  PlayerGuidNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerGuidNotify& from);
  void MergeFrom(const PlayerGuidNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clientGuid = 1;
  inline bool has_clientguid() const;
  inline void clear_clientguid();
  static const int kClientGuidFieldNumber = 1;
  inline ::google::protobuf::uint32 clientguid() const;
  inline void set_clientguid(::google::protobuf::uint32 value);

  // optional bytes uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const void* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // optional bytes token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional int32 robot = 4;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 4;
  inline ::google::protobuf::int32 robot() const;
  inline void set_robot(::google::protobuf::int32 value);

  // optional bytes securityKey = 5;
  inline bool has_securitykey() const;
  inline void clear_securitykey();
  static const int kSecurityKeyFieldNumber = 5;
  inline const ::std::string& securitykey() const;
  inline void set_securitykey(const ::std::string& value);
  inline void set_securitykey(const char* value);
  inline void set_securitykey(const void* value, size_t size);
  inline ::std::string* mutable_securitykey();
  inline ::std::string* release_securitykey();
  inline void set_allocated_securitykey(::std::string* securitykey);

  // @@protoc_insertion_point(class_scope:pb.PlayerGuidNotify)
 private:
  inline void set_has_clientguid();
  inline void clear_has_clientguid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_securitykey();
  inline void clear_has_securitykey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uid_;
  ::google::protobuf::uint32 clientguid_;
  ::google::protobuf::int32 robot_;
  ::std::string* token_;
  ::std::string* securitykey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static PlayerGuidNotify* default_instance_;
};
// -------------------------------------------------------------------

class SetPacketStat : public ::google::protobuf::Message {
 public:
  SetPacketStat();
  virtual ~SetPacketStat();

  SetPacketStat(const SetPacketStat& from);

  inline SetPacketStat& operator=(const SetPacketStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPacketStat& default_instance();

  void Swap(SetPacketStat* other);

  // implements Message ----------------------------------------------

  SetPacketStat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetPacketStat& from);
  void MergeFrom(const SetPacketStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool needStat = 1;
  inline bool has_needstat() const;
  inline void clear_needstat();
  static const int kNeedStatFieldNumber = 1;
  inline bool needstat() const;
  inline void set_needstat(bool value);

  // optional bool needStatTime = 2;
  inline bool has_needstattime() const;
  inline void clear_needstattime();
  static const int kNeedStatTimeFieldNumber = 2;
  inline bool needstattime() const;
  inline void set_needstattime(bool value);

  // @@protoc_insertion_point(class_scope:pb.SetPacketStat)
 private:
  inline void set_has_needstat();
  inline void clear_has_needstat();
  inline void set_has_needstattime();
  inline void clear_has_needstattime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool needstat_;
  bool needstattime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static SetPacketStat* default_instance_;
};
// -------------------------------------------------------------------

class UploadFileReq : public ::google::protobuf::Message {
 public:
  UploadFileReq();
  virtual ~UploadFileReq();

  UploadFileReq(const UploadFileReq& from);

  inline UploadFileReq& operator=(const UploadFileReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadFileReq& default_instance();

  void Swap(UploadFileReq* other);

  // implements Message ----------------------------------------------

  UploadFileReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadFileReq& from);
  void MergeFrom(const UploadFileReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string roleName = 2;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 2;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // @@protoc_insertion_point(class_scope:pb.UploadFileReq)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_rolename();
  inline void clear_has_rolename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::std::string* rolename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static UploadFileReq* default_instance_;
};
// -------------------------------------------------------------------

class UploadFileReply : public ::google::protobuf::Message {
 public:
  UploadFileReply();
  virtual ~UploadFileReply();

  UploadFileReply(const UploadFileReply& from);

  inline UploadFileReply& operator=(const UploadFileReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadFileReply& default_instance();

  void Swap(UploadFileReply* other);

  // implements Message ----------------------------------------------

  UploadFileReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UploadFileReply& from);
  void MergeFrom(const UploadFileReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string roleName = 1;
  inline bool has_rolename() const;
  inline void clear_rolename();
  static const int kRoleNameFieldNumber = 1;
  inline const ::std::string& rolename() const;
  inline void set_rolename(const ::std::string& value);
  inline void set_rolename(const char* value);
  inline void set_rolename(const char* value, size_t size);
  inline ::std::string* mutable_rolename();
  inline ::std::string* release_rolename();
  inline void set_allocated_rolename(::std::string* rolename);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:pb.UploadFileReply)
 private:
  inline void set_has_rolename();
  inline void clear_has_rolename();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rolename_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static UploadFileReply* default_instance_;
};
// -------------------------------------------------------------------

class CollectModuleInfo : public ::google::protobuf::Message {
 public:
  CollectModuleInfo();
  virtual ~CollectModuleInfo();

  CollectModuleInfo(const CollectModuleInfo& from);

  inline CollectModuleInfo& operator=(const CollectModuleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectModuleInfo& default_instance();

  void Swap(CollectModuleInfo* other);

  // implements Message ----------------------------------------------

  CollectModuleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectModuleInfo& from);
  void MergeFrom(const CollectModuleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // optional bytes sign = 2;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 2;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const void* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // optional bytes modulePath = 3;
  inline bool has_modulepath() const;
  inline void clear_modulepath();
  static const int kModulePathFieldNumber = 3;
  inline const ::std::string& modulepath() const;
  inline void set_modulepath(const ::std::string& value);
  inline void set_modulepath(const char* value);
  inline void set_modulepath(const void* value, size_t size);
  inline ::std::string* mutable_modulepath();
  inline ::std::string* release_modulepath();
  inline void set_allocated_modulepath(::std::string* modulepath);

  // optional uint32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.CollectModuleInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_modulepath();
  inline void clear_has_modulepath();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sign_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 time_;
  ::std::string* modulepath_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static CollectModuleInfo* default_instance_;
};
// -------------------------------------------------------------------

class SyncItemLock : public ::google::protobuf::Message {
 public:
  SyncItemLock();
  virtual ~SyncItemLock();

  SyncItemLock(const SyncItemLock& from);

  inline SyncItemLock& operator=(const SyncItemLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncItemLock& default_instance();

  void Swap(SyncItemLock* other);

  // implements Message ----------------------------------------------

  SyncItemLock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncItemLock& from);
  void MergeFrom(const SyncItemLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional uint32 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // optional bool lock = 3 [default = true];
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 3;
  inline bool lock() const;
  inline void set_lock(bool value);

  // @@protoc_insertion_point(class_scope:pb.SyncItemLock)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_lock();
  inline void clear_has_lock();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::uint32 playerid_;
  bool lock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static SyncItemLock* default_instance_;
};
// -------------------------------------------------------------------

class OneString : public ::google::protobuf::Message {
 public:
  OneString();
  virtual ~OneString();

  OneString(const OneString& from);

  inline OneString& operator=(const OneString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OneString& default_instance();

  void Swap(OneString* other);

  // implements Message ----------------------------------------------

  OneString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OneString& from);
  void MergeFrom(const OneString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:pb.OneString)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_packetSystem_2eproto();
  friend void protobuf_AssignDesc_packetSystem_2eproto();
  friend void protobuf_ShutdownFile_packetSystem_2eproto();

  void InitAsDefaultInstance();
  static OneString* default_instance_;
};
// ===================================================================


// ===================================================================

// EmptyPacket

// -------------------------------------------------------------------

// Update

// optional uint32 now = 1;
inline bool Update::has_now() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Update::set_has_now() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Update::clear_has_now() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Update::clear_now() {
  now_ = 0u;
  clear_has_now();
}
inline ::google::protobuf::uint32 Update::now() const {
  return now_;
}
inline void Update::set_now(::google::protobuf::uint32 value) {
  set_has_now();
  now_ = value;
}

// optional uint32 delta = 2;
inline bool Update::has_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Update::set_has_delta() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Update::clear_has_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Update::clear_delta() {
  delta_ = 0u;
  clear_has_delta();
}
inline ::google::protobuf::uint32 Update::delta() const {
  return delta_;
}
inline void Update::set_delta(::google::protobuf::uint32 value) {
  set_has_delta();
  delta_ = value;
}

// -------------------------------------------------------------------

// ListenConfig

// optional .pb.EConnectionType connectionType = 1;
inline bool ListenConfig::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListenConfig::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListenConfig::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListenConfig::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType ListenConfig::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void ListenConfig::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// optional string listenIP = 2;
inline bool ListenConfig::has_listenip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListenConfig::set_has_listenip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListenConfig::clear_has_listenip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListenConfig::clear_listenip() {
  if (listenip_ != &::google::protobuf::internal::kEmptyString) {
    listenip_->clear();
  }
  clear_has_listenip();
}
inline const ::std::string& ListenConfig::listenip() const {
  return *listenip_;
}
inline void ListenConfig::set_listenip(const ::std::string& value) {
  set_has_listenip();
  if (listenip_ == &::google::protobuf::internal::kEmptyString) {
    listenip_ = new ::std::string;
  }
  listenip_->assign(value);
}
inline void ListenConfig::set_listenip(const char* value) {
  set_has_listenip();
  if (listenip_ == &::google::protobuf::internal::kEmptyString) {
    listenip_ = new ::std::string;
  }
  listenip_->assign(value);
}
inline void ListenConfig::set_listenip(const char* value, size_t size) {
  set_has_listenip();
  if (listenip_ == &::google::protobuf::internal::kEmptyString) {
    listenip_ = new ::std::string;
  }
  listenip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListenConfig::mutable_listenip() {
  set_has_listenip();
  if (listenip_ == &::google::protobuf::internal::kEmptyString) {
    listenip_ = new ::std::string;
  }
  return listenip_;
}
inline ::std::string* ListenConfig::release_listenip() {
  clear_has_listenip();
  if (listenip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = listenip_;
    listenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListenConfig::set_allocated_listenip(::std::string* listenip) {
  if (listenip_ != &::google::protobuf::internal::kEmptyString) {
    delete listenip_;
  }
  if (listenip) {
    set_has_listenip();
    listenip_ = listenip;
  } else {
    clear_has_listenip();
    listenip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 listenPort = 3;
inline bool ListenConfig::has_listenport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListenConfig::set_has_listenport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListenConfig::clear_has_listenport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListenConfig::clear_listenport() {
  listenport_ = 0;
  clear_has_listenport();
}
inline ::google::protobuf::int32 ListenConfig::listenport() const {
  return listenport_;
}
inline void ListenConfig::set_listenport(::google::protobuf::int32 value) {
  set_has_listenport();
  listenport_ = value;
}

// optional int32 maxConnection = 4;
inline bool ListenConfig::has_maxconnection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListenConfig::set_has_maxconnection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListenConfig::clear_has_maxconnection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListenConfig::clear_maxconnection() {
  maxconnection_ = 0;
  clear_has_maxconnection();
}
inline ::google::protobuf::int32 ListenConfig::maxconnection() const {
  return maxconnection_;
}
inline void ListenConfig::set_maxconnection(::google::protobuf::int32 value) {
  set_has_maxconnection();
  maxconnection_ = value;
}

// optional bool udp = 5 [default = true];
inline bool ListenConfig::has_udp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListenConfig::set_has_udp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListenConfig::clear_has_udp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListenConfig::clear_udp() {
  udp_ = true;
  clear_has_udp();
}
inline bool ListenConfig::udp() const {
  return udp_;
}
inline void ListenConfig::set_udp(bool value) {
  set_has_udp();
  udp_ = value;
}

// -------------------------------------------------------------------

// InitServer

// repeated .pb.ListenConfig servers = 1;
inline int InitServer::servers_size() const {
  return servers_.size();
}
inline void InitServer::clear_servers() {
  servers_.Clear();
}
inline const ::pb::ListenConfig& InitServer::servers(int index) const {
  return servers_.Get(index);
}
inline ::pb::ListenConfig* InitServer::mutable_servers(int index) {
  return servers_.Mutable(index);
}
inline ::pb::ListenConfig* InitServer::add_servers() {
  return servers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
InitServer::servers() const {
  return servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
InitServer::mutable_servers() {
  return &servers_;
}

// repeated .pb.ListenConfig clients = 2;
inline int InitServer::clients_size() const {
  return clients_.size();
}
inline void InitServer::clear_clients() {
  clients_.Clear();
}
inline const ::pb::ListenConfig& InitServer::clients(int index) const {
  return clients_.Get(index);
}
inline ::pb::ListenConfig* InitServer::mutable_clients(int index) {
  return clients_.Mutable(index);
}
inline ::pb::ListenConfig* InitServer::add_clients() {
  return clients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
InitServer::clients() const {
  return clients_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
InitServer::mutable_clients() {
  return &clients_;
}

// optional uint32 serverGuid = 3;
inline bool InitServer::has_serverguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitServer::set_has_serverguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitServer::clear_has_serverguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitServer::clear_serverguid() {
  serverguid_ = 0u;
  clear_has_serverguid();
}
inline ::google::protobuf::uint32 InitServer::serverguid() const {
  return serverguid_;
}
inline void InitServer::set_serverguid(::google::protobuf::uint32 value) {
  set_has_serverguid();
  serverguid_ = value;
}

// optional string serverName = 4;
inline bool InitServer::has_servername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitServer::set_has_servername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitServer::clear_has_servername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitServer::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& InitServer::servername() const {
  return *servername_;
}
inline void InitServer::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void InitServer::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void InitServer::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitServer::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* InitServer::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InitServer::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pb.EConnectionType connectionType = 5;
inline bool InitServer::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitServer::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitServer::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitServer::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType InitServer::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void InitServer::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// -------------------------------------------------------------------

// SetServerInfo

// optional uint32 serverGuid = 1;
inline bool SetServerInfo::has_serverguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetServerInfo::set_has_serverguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetServerInfo::clear_has_serverguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetServerInfo::clear_serverguid() {
  serverguid_ = 0u;
  clear_has_serverguid();
}
inline ::google::protobuf::uint32 SetServerInfo::serverguid() const {
  return serverguid_;
}
inline void SetServerInfo::set_serverguid(::google::protobuf::uint32 value) {
  set_has_serverguid();
  serverguid_ = value;
}

// optional string serverName = 2;
inline bool SetServerInfo::has_servername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetServerInfo::set_has_servername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetServerInfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetServerInfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& SetServerInfo::servername() const {
  return *servername_;
}
inline void SetServerInfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void SetServerInfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void SetServerInfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetServerInfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* SetServerInfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetServerInfo::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 3;
inline bool SetServerInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetServerInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetServerInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetServerInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SetServerInfo::level() const {
  return level_;
}
inline void SetServerInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 maxPlayerCount = 4;
inline bool SetServerInfo::has_maxplayercount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetServerInfo::set_has_maxplayercount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetServerInfo::clear_has_maxplayercount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetServerInfo::clear_maxplayercount() {
  maxplayercount_ = 0;
  clear_has_maxplayercount();
}
inline ::google::protobuf::int32 SetServerInfo::maxplayercount() const {
  return maxplayercount_;
}
inline void SetServerInfo::set_maxplayercount(::google::protobuf::int32 value) {
  set_has_maxplayercount();
  maxplayercount_ = value;
}

// -------------------------------------------------------------------

// InitServerResponse

// repeated .pb.ListenConfig remoteServers = 1;
inline int InitServerResponse::remoteservers_size() const {
  return remoteservers_.size();
}
inline void InitServerResponse::clear_remoteservers() {
  remoteservers_.Clear();
}
inline const ::pb::ListenConfig& InitServerResponse::remoteservers(int index) const {
  return remoteservers_.Get(index);
}
inline ::pb::ListenConfig* InitServerResponse::mutable_remoteservers(int index) {
  return remoteservers_.Mutable(index);
}
inline ::pb::ListenConfig* InitServerResponse::add_remoteservers() {
  return remoteservers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >&
InitServerResponse::remoteservers() const {
  return remoteservers_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ListenConfig >*
InitServerResponse::mutable_remoteservers() {
  return &remoteservers_;
}

// -------------------------------------------------------------------

// ServerActive

// optional .pb.ListenConfig remoteServer = 1;
inline bool ServerActive::has_remoteserver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerActive::set_has_remoteserver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerActive::clear_has_remoteserver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerActive::clear_remoteserver() {
  if (remoteserver_ != NULL) remoteserver_->::pb::ListenConfig::Clear();
  clear_has_remoteserver();
}
inline const ::pb::ListenConfig& ServerActive::remoteserver() const {
  return remoteserver_ != NULL ? *remoteserver_ : *default_instance_->remoteserver_;
}
inline ::pb::ListenConfig* ServerActive::mutable_remoteserver() {
  set_has_remoteserver();
  if (remoteserver_ == NULL) remoteserver_ = new ::pb::ListenConfig;
  return remoteserver_;
}
inline ::pb::ListenConfig* ServerActive::release_remoteserver() {
  clear_has_remoteserver();
  ::pb::ListenConfig* temp = remoteserver_;
  remoteserver_ = NULL;
  return temp;
}
inline void ServerActive::set_allocated_remoteserver(::pb::ListenConfig* remoteserver) {
  delete remoteserver_;
  remoteserver_ = remoteserver;
  if (remoteserver) {
    set_has_remoteserver();
  } else {
    clear_has_remoteserver();
  }
}

// -------------------------------------------------------------------

// InitGate

// optional string gateAddress = 1;
inline bool InitGate::has_gateaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitGate::set_has_gateaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitGate::clear_has_gateaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitGate::clear_gateaddress() {
  if (gateaddress_ != &::google::protobuf::internal::kEmptyString) {
    gateaddress_->clear();
  }
  clear_has_gateaddress();
}
inline const ::std::string& InitGate::gateaddress() const {
  return *gateaddress_;
}
inline void InitGate::set_gateaddress(const ::std::string& value) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(value);
}
inline void InitGate::set_gateaddress(const char* value) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(value);
}
inline void InitGate::set_gateaddress(const char* value, size_t size) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitGate::mutable_gateaddress() {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  return gateaddress_;
}
inline ::std::string* InitGate::release_gateaddress() {
  clear_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateaddress_;
    gateaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InitGate::set_allocated_gateaddress(::std::string* gateaddress) {
  if (gateaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete gateaddress_;
  }
  if (gateaddress) {
    set_has_gateaddress();
    gateaddress_ = gateaddress;
  } else {
    clear_has_gateaddress();
    gateaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gatePort = 2;
inline bool InitGate::has_gateport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitGate::set_has_gateport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitGate::clear_has_gateport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitGate::clear_gateport() {
  gateport_ = 0;
  clear_has_gateport();
}
inline ::google::protobuf::int32 InitGate::gateport() const {
  return gateport_;
}
inline void InitGate::set_gateport(::google::protobuf::int32 value) {
  set_has_gateport();
  gateport_ = value;
}

// optional uint32 gateGuid = 3;
inline bool InitGate::has_gateguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitGate::set_has_gateguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitGate::clear_has_gateguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitGate::clear_gateguid() {
  gateguid_ = 0u;
  clear_has_gateguid();
}
inline ::google::protobuf::uint32 InitGate::gateguid() const {
  return gateguid_;
}
inline void InitGate::set_gateguid(::google::protobuf::uint32 value) {
  set_has_gateguid();
  gateguid_ = value;
}

// -------------------------------------------------------------------

// ClientConnectGate

// optional string gateAddress = 1;
inline bool ClientConnectGate::has_gateaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientConnectGate::set_has_gateaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientConnectGate::clear_has_gateaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientConnectGate::clear_gateaddress() {
  if (gateaddress_ != &::google::protobuf::internal::kEmptyString) {
    gateaddress_->clear();
  }
  clear_has_gateaddress();
}
inline const ::std::string& ClientConnectGate::gateaddress() const {
  return *gateaddress_;
}
inline void ClientConnectGate::set_gateaddress(const ::std::string& value) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(value);
}
inline void ClientConnectGate::set_gateaddress(const char* value) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(value);
}
inline void ClientConnectGate::set_gateaddress(const char* value, size_t size) {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  gateaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientConnectGate::mutable_gateaddress() {
  set_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    gateaddress_ = new ::std::string;
  }
  return gateaddress_;
}
inline ::std::string* ClientConnectGate::release_gateaddress() {
  clear_has_gateaddress();
  if (gateaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gateaddress_;
    gateaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientConnectGate::set_allocated_gateaddress(::std::string* gateaddress) {
  if (gateaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete gateaddress_;
  }
  if (gateaddress) {
    set_has_gateaddress();
    gateaddress_ = gateaddress;
  } else {
    clear_has_gateaddress();
    gateaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gatePort = 2;
inline bool ClientConnectGate::has_gateport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConnectGate::set_has_gateport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientConnectGate::clear_has_gateport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientConnectGate::clear_gateport() {
  gateport_ = 0;
  clear_has_gateport();
}
inline ::google::protobuf::int32 ClientConnectGate::gateport() const {
  return gateport_;
}
inline void ClientConnectGate::set_gateport(::google::protobuf::int32 value) {
  set_has_gateport();
  gateport_ = value;
}

// optional uint32 newGuid = 3;
inline bool ClientConnectGate::has_newguid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientConnectGate::set_has_newguid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientConnectGate::clear_has_newguid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientConnectGate::clear_newguid() {
  newguid_ = 0u;
  clear_has_newguid();
}
inline ::google::protobuf::uint32 ClientConnectGate::newguid() const {
  return newguid_;
}
inline void ClientConnectGate::set_newguid(::google::protobuf::uint32 value) {
  set_has_newguid();
  newguid_ = value;
}

// optional uint32 waitNum = 4;
inline bool ClientConnectGate::has_waitnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientConnectGate::set_has_waitnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientConnectGate::clear_has_waitnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientConnectGate::clear_waitnum() {
  waitnum_ = 0u;
  clear_has_waitnum();
}
inline ::google::protobuf::uint32 ClientConnectGate::waitnum() const {
  return waitnum_;
}
inline void ClientConnectGate::set_waitnum(::google::protobuf::uint32 value) {
  set_has_waitnum();
  waitnum_ = value;
}

// optional bytes securityKey = 5;
inline bool ClientConnectGate::has_securitykey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientConnectGate::set_has_securitykey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientConnectGate::clear_has_securitykey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientConnectGate::clear_securitykey() {
  if (securitykey_ != &::google::protobuf::internal::kEmptyString) {
    securitykey_->clear();
  }
  clear_has_securitykey();
}
inline const ::std::string& ClientConnectGate::securitykey() const {
  return *securitykey_;
}
inline void ClientConnectGate::set_securitykey(const ::std::string& value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
}
inline void ClientConnectGate::set_securitykey(const char* value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
}
inline void ClientConnectGate::set_securitykey(const void* value, size_t size) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientConnectGate::mutable_securitykey() {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  return securitykey_;
}
inline ::std::string* ClientConnectGate::release_securitykey() {
  clear_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitykey_;
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientConnectGate::set_allocated_securitykey(::std::string* securitykey) {
  if (securitykey_ != &::google::protobuf::internal::kEmptyString) {
    delete securitykey_;
  }
  if (securitykey) {
    set_has_securitykey();
    securitykey_ = securitykey;
  } else {
    clear_has_securitykey();
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeServerGuid

// optional uint32 newGuid = 1;
inline bool ChangeServerGuid::has_newguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeServerGuid::set_has_newguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeServerGuid::clear_has_newguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeServerGuid::clear_newguid() {
  newguid_ = 0u;
  clear_has_newguid();
}
inline ::google::protobuf::uint32 ChangeServerGuid::newguid() const {
  return newguid_;
}
inline void ChangeServerGuid::set_newguid(::google::protobuf::uint32 value) {
  set_has_newguid();
  newguid_ = value;
}

// optional uint32 serverGuid = 2;
inline bool ChangeServerGuid::has_serverguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeServerGuid::set_has_serverguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeServerGuid::clear_has_serverguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeServerGuid::clear_serverguid() {
  serverguid_ = 0u;
  clear_has_serverguid();
}
inline ::google::protobuf::uint32 ChangeServerGuid::serverguid() const {
  return serverguid_;
}
inline void ChangeServerGuid::set_serverguid(::google::protobuf::uint32 value) {
  set_has_serverguid();
  serverguid_ = value;
}

// optional uint32 groupID = 3;
inline bool ChangeServerGuid::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeServerGuid::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeServerGuid::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeServerGuid::clear_groupid() {
  groupid_ = 0u;
  clear_has_groupid();
}
inline ::google::protobuf::uint32 ChangeServerGuid::groupid() const {
  return groupid_;
}
inline void ChangeServerGuid::set_groupid(::google::protobuf::uint32 value) {
  set_has_groupid();
  groupid_ = value;
}

// -------------------------------------------------------------------

// GatePlayerCount

// optional uint32 gateGuid = 1;
inline bool GatePlayerCount::has_gateguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GatePlayerCount::set_has_gateguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GatePlayerCount::clear_has_gateguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GatePlayerCount::clear_gateguid() {
  gateguid_ = 0u;
  clear_has_gateguid();
}
inline ::google::protobuf::uint32 GatePlayerCount::gateguid() const {
  return gateguid_;
}
inline void GatePlayerCount::set_gateguid(::google::protobuf::uint32 value) {
  set_has_gateguid();
  gateguid_ = value;
}

// optional int32 playerCount = 2;
inline bool GatePlayerCount::has_playercount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GatePlayerCount::set_has_playercount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GatePlayerCount::clear_has_playercount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GatePlayerCount::clear_playercount() {
  playercount_ = 0;
  clear_has_playercount();
}
inline ::google::protobuf::int32 GatePlayerCount::playercount() const {
  return playercount_;
}
inline void GatePlayerCount::set_playercount(::google::protobuf::int32 value) {
  set_has_playercount();
  playercount_ = value;
}

// -------------------------------------------------------------------

// NewIncomingConnection

// optional .pb.EConnectionType connectionType = 1;
inline bool NewIncomingConnection::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewIncomingConnection::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewIncomingConnection::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewIncomingConnection::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType NewIncomingConnection::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void NewIncomingConnection::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// optional uint32 remoteGuid = 2;
inline bool NewIncomingConnection::has_remoteguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewIncomingConnection::set_has_remoteguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewIncomingConnection::clear_has_remoteguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewIncomingConnection::clear_remoteguid() {
  remoteguid_ = 0u;
  clear_has_remoteguid();
}
inline ::google::protobuf::uint32 NewIncomingConnection::remoteguid() const {
  return remoteguid_;
}
inline void NewIncomingConnection::set_remoteguid(::google::protobuf::uint32 value) {
  set_has_remoteguid();
  remoteguid_ = value;
}

// -------------------------------------------------------------------

// ConnectionRequestAccepted

// optional .pb.EConnectionType connectionType = 1;
inline bool ConnectionRequestAccepted::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionRequestAccepted::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionRequestAccepted::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionRequestAccepted::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType ConnectionRequestAccepted::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void ConnectionRequestAccepted::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// optional uint32 remoteGuid = 2;
inline bool ConnectionRequestAccepted::has_remoteguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionRequestAccepted::set_has_remoteguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionRequestAccepted::clear_has_remoteguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionRequestAccepted::clear_remoteguid() {
  remoteguid_ = 0u;
  clear_has_remoteguid();
}
inline ::google::protobuf::uint32 ConnectionRequestAccepted::remoteguid() const {
  return remoteguid_;
}
inline void ConnectionRequestAccepted::set_remoteguid(::google::protobuf::uint32 value) {
  set_has_remoteguid();
  remoteguid_ = value;
}

// -------------------------------------------------------------------

// ConnectionAttemptFailed

// optional uint32 remoteGuid = 1;
inline bool ConnectionAttemptFailed::has_remoteguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectionAttemptFailed::set_has_remoteguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectionAttemptFailed::clear_has_remoteguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectionAttemptFailed::clear_remoteguid() {
  remoteguid_ = 0u;
  clear_has_remoteguid();
}
inline ::google::protobuf::uint32 ConnectionAttemptFailed::remoteguid() const {
  return remoteguid_;
}
inline void ConnectionAttemptFailed::set_remoteguid(::google::protobuf::uint32 value) {
  set_has_remoteguid();
  remoteguid_ = value;
}

// optional string IP = 2;
inline bool ConnectionAttemptFailed::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectionAttemptFailed::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectionAttemptFailed::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectionAttemptFailed::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ConnectionAttemptFailed::ip() const {
  return *ip_;
}
inline void ConnectionAttemptFailed::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ConnectionAttemptFailed::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ConnectionAttemptFailed::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConnectionAttemptFailed::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ConnectionAttemptFailed::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConnectionAttemptFailed::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool ConnectionAttemptFailed::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectionAttemptFailed::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectionAttemptFailed::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectionAttemptFailed::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ConnectionAttemptFailed::port() const {
  return port_;
}
inline void ConnectionAttemptFailed::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional .pb.EConnectionType connectionType = 4;
inline bool ConnectionAttemptFailed::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectionAttemptFailed::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectionAttemptFailed::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectionAttemptFailed::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType ConnectionAttemptFailed::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void ConnectionAttemptFailed::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// -------------------------------------------------------------------

// DisconnectionNotification

// optional .pb.EConnectionType connectionType = 1;
inline bool DisconnectionNotification::has_connectiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisconnectionNotification::set_has_connectiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisconnectionNotification::clear_has_connectiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisconnectionNotification::clear_connectiontype() {
  connectiontype_ = -1;
  clear_has_connectiontype();
}
inline ::pb::EConnectionType DisconnectionNotification::connectiontype() const {
  return static_cast< ::pb::EConnectionType >(connectiontype_);
}
inline void DisconnectionNotification::set_connectiontype(::pb::EConnectionType value) {
  assert(::pb::EConnectionType_IsValid(value));
  set_has_connectiontype();
  connectiontype_ = value;
}

// optional uint32 remoteGuid = 2;
inline bool DisconnectionNotification::has_remoteguid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisconnectionNotification::set_has_remoteguid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisconnectionNotification::clear_has_remoteguid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisconnectionNotification::clear_remoteguid() {
  remoteguid_ = 0u;
  clear_has_remoteguid();
}
inline ::google::protobuf::uint32 DisconnectionNotification::remoteguid() const {
  return remoteguid_;
}
inline void DisconnectionNotification::set_remoteguid(::google::protobuf::uint32 value) {
  set_has_remoteguid();
  remoteguid_ = value;
}

// optional bool bPassive = 3 [default = false];
inline bool DisconnectionNotification::has_bpassive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisconnectionNotification::set_has_bpassive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisconnectionNotification::clear_has_bpassive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisconnectionNotification::clear_bpassive() {
  bpassive_ = false;
  clear_has_bpassive();
}
inline bool DisconnectionNotification::bpassive() const {
  return bpassive_;
}
inline void DisconnectionNotification::set_bpassive(bool value) {
  set_has_bpassive();
  bpassive_ = value;
}

// -------------------------------------------------------------------

// LoginError

// optional uint32 playerGuid = 1;
inline bool LoginError::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginError::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginError::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginError::clear_playerguid() {
  playerguid_ = 0u;
  clear_has_playerguid();
}
inline ::google::protobuf::uint32 LoginError::playerguid() const {
  return playerguid_;
}
inline void LoginError::set_playerguid(::google::protobuf::uint32 value) {
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// FlushConfig

// optional string flushModule = 1;
inline bool FlushConfig::has_flushmodule() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushConfig::set_has_flushmodule() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushConfig::clear_has_flushmodule() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushConfig::clear_flushmodule() {
  if (flushmodule_ != &::google::protobuf::internal::kEmptyString) {
    flushmodule_->clear();
  }
  clear_has_flushmodule();
}
inline const ::std::string& FlushConfig::flushmodule() const {
  return *flushmodule_;
}
inline void FlushConfig::set_flushmodule(const ::std::string& value) {
  set_has_flushmodule();
  if (flushmodule_ == &::google::protobuf::internal::kEmptyString) {
    flushmodule_ = new ::std::string;
  }
  flushmodule_->assign(value);
}
inline void FlushConfig::set_flushmodule(const char* value) {
  set_has_flushmodule();
  if (flushmodule_ == &::google::protobuf::internal::kEmptyString) {
    flushmodule_ = new ::std::string;
  }
  flushmodule_->assign(value);
}
inline void FlushConfig::set_flushmodule(const char* value, size_t size) {
  set_has_flushmodule();
  if (flushmodule_ == &::google::protobuf::internal::kEmptyString) {
    flushmodule_ = new ::std::string;
  }
  flushmodule_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FlushConfig::mutable_flushmodule() {
  set_has_flushmodule();
  if (flushmodule_ == &::google::protobuf::internal::kEmptyString) {
    flushmodule_ = new ::std::string;
  }
  return flushmodule_;
}
inline ::std::string* FlushConfig::release_flushmodule() {
  clear_has_flushmodule();
  if (flushmodule_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flushmodule_;
    flushmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FlushConfig::set_allocated_flushmodule(::std::string* flushmodule) {
  if (flushmodule_ != &::google::protobuf::internal::kEmptyString) {
    delete flushmodule_;
  }
  if (flushmodule) {
    set_has_flushmodule();
    flushmodule_ = flushmodule;
  } else {
    clear_has_flushmodule();
    flushmodule_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ShutServerDown

// optional int32 afterTime = 1;
inline bool ShutServerDown::has_aftertime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShutServerDown::set_has_aftertime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShutServerDown::clear_has_aftertime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShutServerDown::clear_aftertime() {
  aftertime_ = 0;
  clear_has_aftertime();
}
inline ::google::protobuf::int32 ShutServerDown::aftertime() const {
  return aftertime_;
}
inline void ShutServerDown::set_aftertime(::google::protobuf::int32 value) {
  set_has_aftertime();
  aftertime_ = value;
}

// -------------------------------------------------------------------

// ClockDifferential

// optional uint32 beginTime = 1;
inline bool ClockDifferential::has_begintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClockDifferential::set_has_begintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClockDifferential::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClockDifferential::clear_begintime() {
  begintime_ = 0u;
  clear_has_begintime();
}
inline ::google::protobuf::uint32 ClockDifferential::begintime() const {
  return begintime_;
}
inline void ClockDifferential::set_begintime(::google::protobuf::uint32 value) {
  set_has_begintime();
  begintime_ = value;
}

// optional uint32 syncTime = 2;
inline bool ClockDifferential::has_synctime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClockDifferential::set_has_synctime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClockDifferential::clear_has_synctime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClockDifferential::clear_synctime() {
  synctime_ = 0u;
  clear_has_synctime();
}
inline ::google::protobuf::uint32 ClockDifferential::synctime() const {
  return synctime_;
}
inline void ClockDifferential::set_synctime(::google::protobuf::uint32 value) {
  set_has_synctime();
  synctime_ = value;
}

// optional uint32 guid = 3;
inline bool ClockDifferential::has_guid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClockDifferential::set_has_guid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClockDifferential::clear_has_guid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClockDifferential::clear_guid() {
  guid_ = 0u;
  clear_has_guid();
}
inline ::google::protobuf::uint32 ClockDifferential::guid() const {
  return guid_;
}
inline void ClockDifferential::set_guid(::google::protobuf::uint32 value) {
  set_has_guid();
  guid_ = value;
}

// -------------------------------------------------------------------

// Bulletin

// optional string content = 1;
inline bool Bulletin::has_content() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bulletin::set_has_content() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bulletin::clear_has_content() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bulletin::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& Bulletin::content() const {
  return *content_;
}
inline void Bulletin::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Bulletin::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void Bulletin::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bulletin::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* Bulletin::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bulletin::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VersionCheck

// optional string version = 1;
inline bool VersionCheck::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionCheck::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionCheck::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionCheck::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& VersionCheck::version() const {
  return *version_;
}
inline void VersionCheck::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionCheck::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void VersionCheck::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VersionCheck::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* VersionCheck::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VersionCheck::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 guid = 2;
inline bool VersionCheck::has_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionCheck::set_has_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionCheck::clear_has_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionCheck::clear_guid() {
  guid_ = 0u;
  clear_has_guid();
}
inline ::google::protobuf::uint32 VersionCheck::guid() const {
  return guid_;
}
inline void VersionCheck::set_guid(::google::protobuf::uint32 value) {
  set_has_guid();
  guid_ = value;
}

// -------------------------------------------------------------------

// VersionCheckFaild

// -------------------------------------------------------------------

// ProxyMessage

// optional uint32 playerGuid = 1;
inline bool ProxyMessage::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProxyMessage::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProxyMessage::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProxyMessage::clear_playerguid() {
  playerguid_ = 0u;
  clear_has_playerguid();
}
inline ::google::protobuf::uint32 ProxyMessage::playerguid() const {
  return playerguid_;
}
inline void ProxyMessage::set_playerguid(::google::protobuf::uint32 value) {
  set_has_playerguid();
  playerguid_ = value;
}

// optional bool status = 2;
inline bool ProxyMessage::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProxyMessage::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProxyMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProxyMessage::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool ProxyMessage::status() const {
  return status_;
}
inline void ProxyMessage::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ReInitProxy

// -------------------------------------------------------------------

// PakCheckCodeQuery

// optional string version = 1;
inline bool PakCheckCodeQuery::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PakCheckCodeQuery::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PakCheckCodeQuery::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PakCheckCodeQuery::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& PakCheckCodeQuery::version() const {
  return *version_;
}
inline void PakCheckCodeQuery::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PakCheckCodeQuery::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void PakCheckCodeQuery::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PakCheckCodeQuery::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* PakCheckCodeQuery::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PakCheckCodeQuery::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PakCheckCode

// optional string pakName = 1;
inline bool PakCheckCode::has_pakname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PakCheckCode::set_has_pakname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PakCheckCode::clear_has_pakname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PakCheckCode::clear_pakname() {
  if (pakname_ != &::google::protobuf::internal::kEmptyString) {
    pakname_->clear();
  }
  clear_has_pakname();
}
inline const ::std::string& PakCheckCode::pakname() const {
  return *pakname_;
}
inline void PakCheckCode::set_pakname(const ::std::string& value) {
  set_has_pakname();
  if (pakname_ == &::google::protobuf::internal::kEmptyString) {
    pakname_ = new ::std::string;
  }
  pakname_->assign(value);
}
inline void PakCheckCode::set_pakname(const char* value) {
  set_has_pakname();
  if (pakname_ == &::google::protobuf::internal::kEmptyString) {
    pakname_ = new ::std::string;
  }
  pakname_->assign(value);
}
inline void PakCheckCode::set_pakname(const char* value, size_t size) {
  set_has_pakname();
  if (pakname_ == &::google::protobuf::internal::kEmptyString) {
    pakname_ = new ::std::string;
  }
  pakname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PakCheckCode::mutable_pakname() {
  set_has_pakname();
  if (pakname_ == &::google::protobuf::internal::kEmptyString) {
    pakname_ = new ::std::string;
  }
  return pakname_;
}
inline ::std::string* PakCheckCode::release_pakname() {
  clear_has_pakname();
  if (pakname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pakname_;
    pakname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PakCheckCode::set_allocated_pakname(::std::string* pakname) {
  if (pakname_ != &::google::protobuf::internal::kEmptyString) {
    delete pakname_;
  }
  if (pakname) {
    set_has_pakname();
    pakname_ = pakname;
  } else {
    clear_has_pakname();
    pakname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string checkCode = 2;
inline bool PakCheckCode::has_checkcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PakCheckCode::set_has_checkcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PakCheckCode::clear_has_checkcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PakCheckCode::clear_checkcode() {
  if (checkcode_ != &::google::protobuf::internal::kEmptyString) {
    checkcode_->clear();
  }
  clear_has_checkcode();
}
inline const ::std::string& PakCheckCode::checkcode() const {
  return *checkcode_;
}
inline void PakCheckCode::set_checkcode(const ::std::string& value) {
  set_has_checkcode();
  if (checkcode_ == &::google::protobuf::internal::kEmptyString) {
    checkcode_ = new ::std::string;
  }
  checkcode_->assign(value);
}
inline void PakCheckCode::set_checkcode(const char* value) {
  set_has_checkcode();
  if (checkcode_ == &::google::protobuf::internal::kEmptyString) {
    checkcode_ = new ::std::string;
  }
  checkcode_->assign(value);
}
inline void PakCheckCode::set_checkcode(const char* value, size_t size) {
  set_has_checkcode();
  if (checkcode_ == &::google::protobuf::internal::kEmptyString) {
    checkcode_ = new ::std::string;
  }
  checkcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PakCheckCode::mutable_checkcode() {
  set_has_checkcode();
  if (checkcode_ == &::google::protobuf::internal::kEmptyString) {
    checkcode_ = new ::std::string;
  }
  return checkcode_;
}
inline ::std::string* PakCheckCode::release_checkcode() {
  clear_has_checkcode();
  if (checkcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checkcode_;
    checkcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PakCheckCode::set_allocated_checkcode(::std::string* checkcode) {
  if (checkcode_ != &::google::protobuf::internal::kEmptyString) {
    delete checkcode_;
  }
  if (checkcode) {
    set_has_checkcode();
    checkcode_ = checkcode;
  } else {
    clear_has_checkcode();
    checkcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PakCheckCodeRes

// repeated .pb.PakCheckCode pakCheckCodes = 1;
inline int PakCheckCodeRes::pakcheckcodes_size() const {
  return pakcheckcodes_.size();
}
inline void PakCheckCodeRes::clear_pakcheckcodes() {
  pakcheckcodes_.Clear();
}
inline const ::pb::PakCheckCode& PakCheckCodeRes::pakcheckcodes(int index) const {
  return pakcheckcodes_.Get(index);
}
inline ::pb::PakCheckCode* PakCheckCodeRes::mutable_pakcheckcodes(int index) {
  return pakcheckcodes_.Mutable(index);
}
inline ::pb::PakCheckCode* PakCheckCodeRes::add_pakcheckcodes() {
  return pakcheckcodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PakCheckCode >&
PakCheckCodeRes::pakcheckcodes() const {
  return pakcheckcodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PakCheckCode >*
PakCheckCodeRes::mutable_pakcheckcodes() {
  return &pakcheckcodes_;
}

// -------------------------------------------------------------------

// PakCheckFailed

// repeated string pakNames = 1;
inline int PakCheckFailed::paknames_size() const {
  return paknames_.size();
}
inline void PakCheckFailed::clear_paknames() {
  paknames_.Clear();
}
inline const ::std::string& PakCheckFailed::paknames(int index) const {
  return paknames_.Get(index);
}
inline ::std::string* PakCheckFailed::mutable_paknames(int index) {
  return paknames_.Mutable(index);
}
inline void PakCheckFailed::set_paknames(int index, const ::std::string& value) {
  paknames_.Mutable(index)->assign(value);
}
inline void PakCheckFailed::set_paknames(int index, const char* value) {
  paknames_.Mutable(index)->assign(value);
}
inline void PakCheckFailed::set_paknames(int index, const char* value, size_t size) {
  paknames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PakCheckFailed::add_paknames() {
  return paknames_.Add();
}
inline void PakCheckFailed::add_paknames(const ::std::string& value) {
  paknames_.Add()->assign(value);
}
inline void PakCheckFailed::add_paknames(const char* value) {
  paknames_.Add()->assign(value);
}
inline void PakCheckFailed::add_paknames(const char* value, size_t size) {
  paknames_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PakCheckFailed::paknames() const {
  return paknames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PakCheckFailed::mutable_paknames() {
  return &paknames_;
}

// -------------------------------------------------------------------

// InitPveGameServer

// optional int32 maxPlayerCount = 1;
inline bool InitPveGameServer::has_maxplayercount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitPveGameServer::set_has_maxplayercount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitPveGameServer::clear_has_maxplayercount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitPveGameServer::clear_maxplayercount() {
  maxplayercount_ = 0;
  clear_has_maxplayercount();
}
inline ::google::protobuf::int32 InitPveGameServer::maxplayercount() const {
  return maxplayercount_;
}
inline void InitPveGameServer::set_maxplayercount(::google::protobuf::int32 value) {
  set_has_maxplayercount();
  maxplayercount_ = value;
}

// -------------------------------------------------------------------

// IncPlayer

// optional uint32 playerGuid = 1;
inline bool IncPlayer::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IncPlayer::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IncPlayer::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IncPlayer::clear_playerguid() {
  playerguid_ = 0u;
  clear_has_playerguid();
}
inline ::google::protobuf::uint32 IncPlayer::playerguid() const {
  return playerguid_;
}
inline void IncPlayer::set_playerguid(::google::protobuf::uint32 value) {
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// DeIncPlayer

// -------------------------------------------------------------------

// ClientLog

// required bool error = 1;
inline bool ClientLog::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLog::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLog::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLog::clear_error() {
  error_ = false;
  clear_has_error();
}
inline bool ClientLog::error() const {
  return error_;
}
inline void ClientLog::set_error(bool value) {
  set_has_error();
  error_ = value;
}

// required string machineID = 2;
inline bool ClientLog::has_machineid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientLog::set_has_machineid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientLog::clear_has_machineid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientLog::clear_machineid() {
  if (machineid_ != &::google::protobuf::internal::kEmptyString) {
    machineid_->clear();
  }
  clear_has_machineid();
}
inline const ::std::string& ClientLog::machineid() const {
  return *machineid_;
}
inline void ClientLog::set_machineid(const ::std::string& value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
}
inline void ClientLog::set_machineid(const char* value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
}
inline void ClientLog::set_machineid(const char* value, size_t size) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLog::mutable_machineid() {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  return machineid_;
}
inline ::std::string* ClientLog::release_machineid() {
  clear_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machineid_;
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLog::set_allocated_machineid(::std::string* machineid) {
  if (machineid_ != &::google::protobuf::internal::kEmptyString) {
    delete machineid_;
  }
  if (machineid) {
    set_has_machineid();
    machineid_ = machineid;
  } else {
    clear_has_machineid();
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string content = 3;
inline bool ClientLog::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientLog::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientLog::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientLog::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ClientLog::content() const {
  return *content_;
}
inline void ClientLog::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ClientLog::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ClientLog::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLog::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ClientLog::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLog::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string memoryStatus = 4;
inline bool ClientLog::has_memorystatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientLog::set_has_memorystatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientLog::clear_has_memorystatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientLog::clear_memorystatus() {
  if (memorystatus_ != &::google::protobuf::internal::kEmptyString) {
    memorystatus_->clear();
  }
  clear_has_memorystatus();
}
inline const ::std::string& ClientLog::memorystatus() const {
  return *memorystatus_;
}
inline void ClientLog::set_memorystatus(const ::std::string& value) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(value);
}
inline void ClientLog::set_memorystatus(const char* value) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(value);
}
inline void ClientLog::set_memorystatus(const char* value, size_t size) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientLog::mutable_memorystatus() {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  return memorystatus_;
}
inline ::std::string* ClientLog::release_memorystatus() {
  clear_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memorystatus_;
    memorystatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientLog::set_allocated_memorystatus(::std::string* memorystatus) {
  if (memorystatus_ != &::google::protobuf::internal::kEmptyString) {
    delete memorystatus_;
  }
  if (memorystatus) {
    set_has_memorystatus();
    memorystatus_ = memorystatus;
  } else {
    clear_has_memorystatus();
    memorystatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientDump

// required string machineID = 1;
inline bool ClientDump::has_machineid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDump::set_has_machineid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDump::clear_has_machineid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDump::clear_machineid() {
  if (machineid_ != &::google::protobuf::internal::kEmptyString) {
    machineid_->clear();
  }
  clear_has_machineid();
}
inline const ::std::string& ClientDump::machineid() const {
  return *machineid_;
}
inline void ClientDump::set_machineid(const ::std::string& value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
}
inline void ClientDump::set_machineid(const char* value) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(value);
}
inline void ClientDump::set_machineid(const char* value, size_t size) {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  machineid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDump::mutable_machineid() {
  set_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    machineid_ = new ::std::string;
  }
  return machineid_;
}
inline ::std::string* ClientDump::release_machineid() {
  clear_has_machineid();
  if (machineid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machineid_;
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientDump::set_allocated_machineid(::std::string* machineid) {
  if (machineid_ != &::google::protobuf::internal::kEmptyString) {
    delete machineid_;
  }
  if (machineid) {
    set_has_machineid();
    machineid_ = machineid;
  } else {
    clear_has_machineid();
    machineid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string dumpName = 2;
inline bool ClientDump::has_dumpname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDump::set_has_dumpname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDump::clear_has_dumpname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDump::clear_dumpname() {
  if (dumpname_ != &::google::protobuf::internal::kEmptyString) {
    dumpname_->clear();
  }
  clear_has_dumpname();
}
inline const ::std::string& ClientDump::dumpname() const {
  return *dumpname_;
}
inline void ClientDump::set_dumpname(const ::std::string& value) {
  set_has_dumpname();
  if (dumpname_ == &::google::protobuf::internal::kEmptyString) {
    dumpname_ = new ::std::string;
  }
  dumpname_->assign(value);
}
inline void ClientDump::set_dumpname(const char* value) {
  set_has_dumpname();
  if (dumpname_ == &::google::protobuf::internal::kEmptyString) {
    dumpname_ = new ::std::string;
  }
  dumpname_->assign(value);
}
inline void ClientDump::set_dumpname(const char* value, size_t size) {
  set_has_dumpname();
  if (dumpname_ == &::google::protobuf::internal::kEmptyString) {
    dumpname_ = new ::std::string;
  }
  dumpname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDump::mutable_dumpname() {
  set_has_dumpname();
  if (dumpname_ == &::google::protobuf::internal::kEmptyString) {
    dumpname_ = new ::std::string;
  }
  return dumpname_;
}
inline ::std::string* ClientDump::release_dumpname() {
  clear_has_dumpname();
  if (dumpname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dumpname_;
    dumpname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientDump::set_allocated_dumpname(::std::string* dumpname) {
  if (dumpname_ != &::google::protobuf::internal::kEmptyString) {
    delete dumpname_;
  }
  if (dumpname) {
    set_has_dumpname();
    dumpname_ = dumpname;
  } else {
    clear_has_dumpname();
    dumpname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes dumpContent = 3;
inline bool ClientDump::has_dumpcontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDump::set_has_dumpcontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDump::clear_has_dumpcontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDump::clear_dumpcontent() {
  if (dumpcontent_ != &::google::protobuf::internal::kEmptyString) {
    dumpcontent_->clear();
  }
  clear_has_dumpcontent();
}
inline const ::std::string& ClientDump::dumpcontent() const {
  return *dumpcontent_;
}
inline void ClientDump::set_dumpcontent(const ::std::string& value) {
  set_has_dumpcontent();
  if (dumpcontent_ == &::google::protobuf::internal::kEmptyString) {
    dumpcontent_ = new ::std::string;
  }
  dumpcontent_->assign(value);
}
inline void ClientDump::set_dumpcontent(const char* value) {
  set_has_dumpcontent();
  if (dumpcontent_ == &::google::protobuf::internal::kEmptyString) {
    dumpcontent_ = new ::std::string;
  }
  dumpcontent_->assign(value);
}
inline void ClientDump::set_dumpcontent(const void* value, size_t size) {
  set_has_dumpcontent();
  if (dumpcontent_ == &::google::protobuf::internal::kEmptyString) {
    dumpcontent_ = new ::std::string;
  }
  dumpcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDump::mutable_dumpcontent() {
  set_has_dumpcontent();
  if (dumpcontent_ == &::google::protobuf::internal::kEmptyString) {
    dumpcontent_ = new ::std::string;
  }
  return dumpcontent_;
}
inline ::std::string* ClientDump::release_dumpcontent() {
  clear_has_dumpcontent();
  if (dumpcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dumpcontent_;
    dumpcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientDump::set_allocated_dumpcontent(::std::string* dumpcontent) {
  if (dumpcontent_ != &::google::protobuf::internal::kEmptyString) {
    delete dumpcontent_;
  }
  if (dumpcontent) {
    set_has_dumpcontent();
    dumpcontent_ = dumpcontent;
  } else {
    clear_has_dumpcontent();
    dumpcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string memoryStatus = 4;
inline bool ClientDump::has_memorystatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientDump::set_has_memorystatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientDump::clear_has_memorystatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientDump::clear_memorystatus() {
  if (memorystatus_ != &::google::protobuf::internal::kEmptyString) {
    memorystatus_->clear();
  }
  clear_has_memorystatus();
}
inline const ::std::string& ClientDump::memorystatus() const {
  return *memorystatus_;
}
inline void ClientDump::set_memorystatus(const ::std::string& value) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(value);
}
inline void ClientDump::set_memorystatus(const char* value) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(value);
}
inline void ClientDump::set_memorystatus(const char* value, size_t size) {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  memorystatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientDump::mutable_memorystatus() {
  set_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    memorystatus_ = new ::std::string;
  }
  return memorystatus_;
}
inline ::std::string* ClientDump::release_memorystatus() {
  clear_has_memorystatus();
  if (memorystatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memorystatus_;
    memorystatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientDump::set_allocated_memorystatus(::std::string* memorystatus) {
  if (memorystatus_ != &::google::protobuf::internal::kEmptyString) {
    delete memorystatus_;
  }
  if (memorystatus) {
    set_has_memorystatus();
    memorystatus_ = memorystatus;
  } else {
    clear_has_memorystatus();
    memorystatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SystemKeepalive

// -------------------------------------------------------------------

// ProxyBalanceAdd

// optional uint32 playerGuid = 1;
inline bool ProxyBalanceAdd::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProxyBalanceAdd::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProxyBalanceAdd::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProxyBalanceAdd::clear_playerguid() {
  playerguid_ = 0u;
  clear_has_playerguid();
}
inline ::google::protobuf::uint32 ProxyBalanceAdd::playerguid() const {
  return playerguid_;
}
inline void ProxyBalanceAdd::set_playerguid(::google::protobuf::uint32 value) {
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// ProxyBalanceDel

// optional uint32 playerGuid = 1;
inline bool ProxyBalanceDel::has_playerguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProxyBalanceDel::set_has_playerguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProxyBalanceDel::clear_has_playerguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProxyBalanceDel::clear_playerguid() {
  playerguid_ = 0u;
  clear_has_playerguid();
}
inline ::google::protobuf::uint32 ProxyBalanceDel::playerguid() const {
  return playerguid_;
}
inline void ProxyBalanceDel::set_playerguid(::google::protobuf::uint32 value) {
  set_has_playerguid();
  playerguid_ = value;
}

// -------------------------------------------------------------------

// InitUdpProxy

// optional string udpProxyHost = 1;
inline bool InitUdpProxy::has_udpproxyhost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitUdpProxy::set_has_udpproxyhost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitUdpProxy::clear_has_udpproxyhost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitUdpProxy::clear_udpproxyhost() {
  if (udpproxyhost_ != &::google::protobuf::internal::kEmptyString) {
    udpproxyhost_->clear();
  }
  clear_has_udpproxyhost();
}
inline const ::std::string& InitUdpProxy::udpproxyhost() const {
  return *udpproxyhost_;
}
inline void InitUdpProxy::set_udpproxyhost(const ::std::string& value) {
  set_has_udpproxyhost();
  if (udpproxyhost_ == &::google::protobuf::internal::kEmptyString) {
    udpproxyhost_ = new ::std::string;
  }
  udpproxyhost_->assign(value);
}
inline void InitUdpProxy::set_udpproxyhost(const char* value) {
  set_has_udpproxyhost();
  if (udpproxyhost_ == &::google::protobuf::internal::kEmptyString) {
    udpproxyhost_ = new ::std::string;
  }
  udpproxyhost_->assign(value);
}
inline void InitUdpProxy::set_udpproxyhost(const char* value, size_t size) {
  set_has_udpproxyhost();
  if (udpproxyhost_ == &::google::protobuf::internal::kEmptyString) {
    udpproxyhost_ = new ::std::string;
  }
  udpproxyhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InitUdpProxy::mutable_udpproxyhost() {
  set_has_udpproxyhost();
  if (udpproxyhost_ == &::google::protobuf::internal::kEmptyString) {
    udpproxyhost_ = new ::std::string;
  }
  return udpproxyhost_;
}
inline ::std::string* InitUdpProxy::release_udpproxyhost() {
  clear_has_udpproxyhost();
  if (udpproxyhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udpproxyhost_;
    udpproxyhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InitUdpProxy::set_allocated_udpproxyhost(::std::string* udpproxyhost) {
  if (udpproxyhost_ != &::google::protobuf::internal::kEmptyString) {
    delete udpproxyhost_;
  }
  if (udpproxyhost) {
    set_has_udpproxyhost();
    udpproxyhost_ = udpproxyhost;
  } else {
    clear_has_udpproxyhost();
    udpproxyhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 udpProxyPort = 2;
inline bool InitUdpProxy::has_udpproxyport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitUdpProxy::set_has_udpproxyport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitUdpProxy::clear_has_udpproxyport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitUdpProxy::clear_udpproxyport() {
  udpproxyport_ = 0;
  clear_has_udpproxyport();
}
inline ::google::protobuf::int32 InitUdpProxy::udpproxyport() const {
  return udpproxyport_;
}
inline void InitUdpProxy::set_udpproxyport(::google::protobuf::int32 value) {
  set_has_udpproxyport();
  udpproxyport_ = value;
}

// -------------------------------------------------------------------

// PlayerGuidNotify

// optional uint32 clientGuid = 1;
inline bool PlayerGuidNotify::has_clientguid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerGuidNotify::set_has_clientguid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerGuidNotify::clear_has_clientguid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerGuidNotify::clear_clientguid() {
  clientguid_ = 0u;
  clear_has_clientguid();
}
inline ::google::protobuf::uint32 PlayerGuidNotify::clientguid() const {
  return clientguid_;
}
inline void PlayerGuidNotify::set_clientguid(::google::protobuf::uint32 value) {
  set_has_clientguid();
  clientguid_ = value;
}

// optional bytes uid = 2;
inline bool PlayerGuidNotify::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerGuidNotify::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerGuidNotify::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerGuidNotify::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& PlayerGuidNotify::uid() const {
  return *uid_;
}
inline void PlayerGuidNotify::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PlayerGuidNotify::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void PlayerGuidNotify::set_uid(const void* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGuidNotify::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* PlayerGuidNotify::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGuidNotify::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes token = 3;
inline bool PlayerGuidNotify::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerGuidNotify::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerGuidNotify::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerGuidNotify::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& PlayerGuidNotify::token() const {
  return *token_;
}
inline void PlayerGuidNotify::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void PlayerGuidNotify::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void PlayerGuidNotify::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGuidNotify::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* PlayerGuidNotify::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGuidNotify::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 robot = 4;
inline bool PlayerGuidNotify::has_robot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerGuidNotify::set_has_robot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerGuidNotify::clear_has_robot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerGuidNotify::clear_robot() {
  robot_ = 0;
  clear_has_robot();
}
inline ::google::protobuf::int32 PlayerGuidNotify::robot() const {
  return robot_;
}
inline void PlayerGuidNotify::set_robot(::google::protobuf::int32 value) {
  set_has_robot();
  robot_ = value;
}

// optional bytes securityKey = 5;
inline bool PlayerGuidNotify::has_securitykey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerGuidNotify::set_has_securitykey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerGuidNotify::clear_has_securitykey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerGuidNotify::clear_securitykey() {
  if (securitykey_ != &::google::protobuf::internal::kEmptyString) {
    securitykey_->clear();
  }
  clear_has_securitykey();
}
inline const ::std::string& PlayerGuidNotify::securitykey() const {
  return *securitykey_;
}
inline void PlayerGuidNotify::set_securitykey(const ::std::string& value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
}
inline void PlayerGuidNotify::set_securitykey(const char* value) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(value);
}
inline void PlayerGuidNotify::set_securitykey(const void* value, size_t size) {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  securitykey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGuidNotify::mutable_securitykey() {
  set_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    securitykey_ = new ::std::string;
  }
  return securitykey_;
}
inline ::std::string* PlayerGuidNotify::release_securitykey() {
  clear_has_securitykey();
  if (securitykey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = securitykey_;
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGuidNotify::set_allocated_securitykey(::std::string* securitykey) {
  if (securitykey_ != &::google::protobuf::internal::kEmptyString) {
    delete securitykey_;
  }
  if (securitykey) {
    set_has_securitykey();
    securitykey_ = securitykey;
  } else {
    clear_has_securitykey();
    securitykey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SetPacketStat

// optional bool needStat = 1;
inline bool SetPacketStat::has_needstat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPacketStat::set_has_needstat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPacketStat::clear_has_needstat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPacketStat::clear_needstat() {
  needstat_ = false;
  clear_has_needstat();
}
inline bool SetPacketStat::needstat() const {
  return needstat_;
}
inline void SetPacketStat::set_needstat(bool value) {
  set_has_needstat();
  needstat_ = value;
}

// optional bool needStatTime = 2;
inline bool SetPacketStat::has_needstattime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPacketStat::set_has_needstattime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPacketStat::clear_has_needstattime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPacketStat::clear_needstattime() {
  needstattime_ = false;
  clear_has_needstattime();
}
inline bool SetPacketStat::needstattime() const {
  return needstattime_;
}
inline void SetPacketStat::set_needstattime(bool value) {
  set_has_needstattime();
  needstattime_ = value;
}

// -------------------------------------------------------------------

// UploadFileReq

// optional string fileName = 1;
inline bool UploadFileReq::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadFileReq::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadFileReq::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadFileReq::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& UploadFileReq::filename() const {
  return *filename_;
}
inline void UploadFileReq::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UploadFileReq::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UploadFileReq::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadFileReq::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* UploadFileReq::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadFileReq::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roleName = 2;
inline bool UploadFileReq::has_rolename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadFileReq::set_has_rolename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadFileReq::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadFileReq::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& UploadFileReq::rolename() const {
  return *rolename_;
}
inline void UploadFileReq::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void UploadFileReq::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void UploadFileReq::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadFileReq::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* UploadFileReq::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadFileReq::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UploadFileReply

// optional string roleName = 1;
inline bool UploadFileReply::has_rolename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadFileReply::set_has_rolename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadFileReply::clear_has_rolename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadFileReply::clear_rolename() {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    rolename_->clear();
  }
  clear_has_rolename();
}
inline const ::std::string& UploadFileReply::rolename() const {
  return *rolename_;
}
inline void UploadFileReply::set_rolename(const ::std::string& value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void UploadFileReply::set_rolename(const char* value) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(value);
}
inline void UploadFileReply::set_rolename(const char* value, size_t size) {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  rolename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadFileReply::mutable_rolename() {
  set_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    rolename_ = new ::std::string;
  }
  return rolename_;
}
inline ::std::string* UploadFileReply::release_rolename() {
  clear_has_rolename();
  if (rolename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rolename_;
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadFileReply::set_allocated_rolename(::std::string* rolename) {
  if (rolename_ != &::google::protobuf::internal::kEmptyString) {
    delete rolename_;
  }
  if (rolename) {
    set_has_rolename();
    rolename_ = rolename;
  } else {
    clear_has_rolename();
    rolename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes data = 2;
inline bool UploadFileReply::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadFileReply::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadFileReply::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadFileReply::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UploadFileReply::data() const {
  return *data_;
}
inline void UploadFileReply::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UploadFileReply::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UploadFileReply::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UploadFileReply::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* UploadFileReply::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UploadFileReply::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CollectModuleInfo

// optional uint32 playerID = 1;
inline bool CollectModuleInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollectModuleInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollectModuleInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollectModuleInfo::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 CollectModuleInfo::playerid() const {
  return playerid_;
}
inline void CollectModuleInfo::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional bytes sign = 2;
inline bool CollectModuleInfo::has_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollectModuleInfo::set_has_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollectModuleInfo::clear_has_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollectModuleInfo::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& CollectModuleInfo::sign() const {
  return *sign_;
}
inline void CollectModuleInfo::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void CollectModuleInfo::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void CollectModuleInfo::set_sign(const void* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectModuleInfo::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* CollectModuleInfo::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollectModuleInfo::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes modulePath = 3;
inline bool CollectModuleInfo::has_modulepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollectModuleInfo::set_has_modulepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollectModuleInfo::clear_has_modulepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollectModuleInfo::clear_modulepath() {
  if (modulepath_ != &::google::protobuf::internal::kEmptyString) {
    modulepath_->clear();
  }
  clear_has_modulepath();
}
inline const ::std::string& CollectModuleInfo::modulepath() const {
  return *modulepath_;
}
inline void CollectModuleInfo::set_modulepath(const ::std::string& value) {
  set_has_modulepath();
  if (modulepath_ == &::google::protobuf::internal::kEmptyString) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline void CollectModuleInfo::set_modulepath(const char* value) {
  set_has_modulepath();
  if (modulepath_ == &::google::protobuf::internal::kEmptyString) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline void CollectModuleInfo::set_modulepath(const void* value, size_t size) {
  set_has_modulepath();
  if (modulepath_ == &::google::protobuf::internal::kEmptyString) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollectModuleInfo::mutable_modulepath() {
  set_has_modulepath();
  if (modulepath_ == &::google::protobuf::internal::kEmptyString) {
    modulepath_ = new ::std::string;
  }
  return modulepath_;
}
inline ::std::string* CollectModuleInfo::release_modulepath() {
  clear_has_modulepath();
  if (modulepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modulepath_;
    modulepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CollectModuleInfo::set_allocated_modulepath(::std::string* modulepath) {
  if (modulepath_ != &::google::protobuf::internal::kEmptyString) {
    delete modulepath_;
  }
  if (modulepath) {
    set_has_modulepath();
    modulepath_ = modulepath;
  } else {
    clear_has_modulepath();
    modulepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 time = 4;
inline bool CollectModuleInfo::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollectModuleInfo::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollectModuleInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollectModuleInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 CollectModuleInfo::time() const {
  return time_;
}
inline void CollectModuleInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// SyncItemLock

// optional string account = 1;
inline bool SyncItemLock::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncItemLock::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncItemLock::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncItemLock::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& SyncItemLock::account() const {
  return *account_;
}
inline void SyncItemLock::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SyncItemLock::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void SyncItemLock::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncItemLock::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* SyncItemLock::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SyncItemLock::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 playerID = 2;
inline bool SyncItemLock::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncItemLock::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncItemLock::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncItemLock::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 SyncItemLock::playerid() const {
  return playerid_;
}
inline void SyncItemLock::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional bool lock = 3 [default = true];
inline bool SyncItemLock::has_lock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncItemLock::set_has_lock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncItemLock::clear_has_lock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncItemLock::clear_lock() {
  lock_ = true;
  clear_has_lock();
}
inline bool SyncItemLock::lock() const {
  return lock_;
}
inline void SyncItemLock::set_lock(bool value) {
  set_has_lock();
  lock_ = value;
}

// -------------------------------------------------------------------

// OneString

// optional string str = 1;
inline bool OneString::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OneString::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OneString::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OneString::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& OneString::str() const {
  return *str_;
}
inline void OneString::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void OneString::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void OneString::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OneString::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* OneString::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OneString::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_packetSystem_2eproto__INCLUDED
